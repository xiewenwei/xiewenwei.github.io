<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[程序人生]]></title>
  <link href="http://xiewenwei.github.com//atom.xml" rel="self"/>
  <link href="http://xiewenwei.github.com//"/>
  <updated>2014-08-11T00:31:37+08:00</updated>
  <id>http://xiewenwei.github.com//</id>
  <author>
    <name><![CDATA[vincent]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[实例探索 Git 的分支 branch 和标签 tag]]></title>
    <link href="http://xiewenwei.github.com//blog/2014/08/10/dig-into-git-branch-and-tag/"/>
    <updated>2014-08-10T23:38:00+08:00</updated>
    <id>http://xiewenwei.github.com//blog/2014/08/10/dig-into-git-branch-and-tag</id>
    <content type="html"><![CDATA[<p>上一篇讲到 Git 的对象模型，通过它已经能够深入了解 Git 背后如何组织和储存数据，但是总觉得还是缺一点什么，那就是 Git 的必杀技分支和对象模型的关系，接下来就通过一些实例来弄清楚 Git 的分支是如何运作的。</p>

<p>在 Git 对象模型中讲到，每一次 Git 提交，都会生成一个 commit 对象，这个 commit 对象有一个 SHA1 key，例如 4240c635214402420f4fd907c378f0d01a5b5d8e。简单的说，Git 的分支就是一个引用 reference，这个引用有一个名称（分支的名称），然后指向一个具体的 commit 对象（通过 commit 对象的 key），就是这么简单。</p>

<p>分支的数据保存在那里呢？都在目录 <code>.git/refs</code> 中，通常这个目录下有三个子目录，分别是 heads，tags 和 remotes。
我们可以看到 <code>.git/refs/heads</code> 下有一些文件，每一个文件表示一个分支，文件的名称就是分支的名称，文件的内容就是 commit 对象的 key。</p>

<p>例如，dig-git 项目里：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cat .git/refs/heads/master
</span><span class='line'>058ca0a55e60eae77dac9818f915dad581b5465b
</span><span class='line'>cat .git/refs/heads/test1
</span><span class='line'>0c5ca6c9e46a1e6cfe04eaea7cd5db3223ba6693</span></code></pre></td></tr></table></div></figure>


<p>是不是很简单，知道了这个原理，我们甚至可以绕开 Git 命令，直接通过文件操作生成一个 branch。
例如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>echo "3c31e0a28cfc7f022984d6f8250a1c5c0670f120" &gt;&gt; ".git/refs/heads/test2"</span></code></pre></td></tr></table></div></figure>


<p>通过上面的命令，在 .git/refs/heads 目录下生成一个 test2 文件，文件内容是一个 commit 对象的 key，这样就生成了一个 test2 分支。</p>

<p>标签 tag 和分支 branch 的本质是一样的，都是一个指向 commit 对象的引用，只不过标签 tag 的文件放在 .git/refs/tags 目录下而已。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[实例探索 Git 对象模型]]></title>
    <link href="http://xiewenwei.github.com//blog/2014/08/03/dig-into-git-object-model/"/>
    <updated>2014-08-03T18:48:00+08:00</updated>
    <id>http://xiewenwei.github.com//blog/2014/08/03/dig-into-git-object-model</id>
    <content type="html"><![CDATA[<p>一个纯研究演示 Git 对象模型的项目，项目在  https://github.com/xiewenwei/dig-git，总共有 5 次 commit（包括一次 merge），都是很简单的内容，我们可以仔细观察一下每一 commit 之后 Git 对象模型图，以此分析 Git 存储的原理。</p>

<ul>
<li><ol>
<li>首次提交，提交一个简单的文件 a.txt ，commit 之后的图如下：</li>
</ol>
</li>
</ul>


<p><img src="https://ruby-china-files.b0.upaiyun.com/photo/2014/9c44291362d64765803afba65fa2a0a4.png" alt="" /></p>

<p>如图所示，生成了 3 个对象，一个 commit 对象，一个 tree 对象，一个 blob 对象。图上蓝底是 commit 对象，灰底的是 tree 对象，白底的是 blob 对象，每个对象节点的标题是对象的 key (SHA 摘要)缩略表示。
对于 commit 对象，tree 内容表示这个 commit 对应根目录的 tree 对象，parent 表示父 commit 节点，通常commit 只有一个父节点，也可能没有（首次提交时 parent 为空），也可能有多个（合并节点），commit 对象还保存了 commit message 等信息。
对于 tree 对象，里面的内容包含了文件名，文件对应的 blob 对象的 key，或者是目录名和目录对应 tree 对象的 key。
对于 blob 对象，表示一个实际文件对象的内容，但不包括文件名，文件名是在 tree 对象里存的。</p>

<p>这个图怎么得到的呢？主要是两个命令：
* 通过 <code>git log</code> 命令获取最新 commit 的 key
* 通过 <code>git cat-file -p &lt;object key&gt;</code>  获取 key 对应 object 的内容，根据 object 里的内容，继续探索，就可以访问到所有关联 object.</p>

<ul>
<li><ol>
<li>第 2 次提交，修改了 a.txt 文件：</li>
</ol>
</li>
</ul>


<p><img src="https://ruby-china-files.b0.upaiyun.com/photo/2014/ba84d2ce8ba5066444a3e382ed644206.png" alt="" /></p>

<p>因为 a.txt 文件已经修改，生成了一个新的 blob 对象，tree 对象和 commit 对象。如图所示，commit 对象之间是有关联的，新提交的 commit 对象的 parent 是上一次提交的 commit 对象。</p>

<ul>
<li><ol>
<li>第 3 次提交，这次已稍微复杂一点，增加一个新文件 b.txt ，一个新目录 lib ，lib 里增加一个文件 c.txt</li>
</ol>
</li>
</ul>


<p><img src="https://ruby-china-files.b0.upaiyun.com/photo/2014/1ab7f0d2ab24734f0af6fc2d8e7c7a7d.png" alt="" /></p>

<p>如图所示，目录是有一个 tree 对象表示的，里面的内容指明了目录包含的文件或子目录。</p>

<ul>
<li><ol>
<li>第 4 次提交，这次弄出一个新的分支 test1，并且在新分支中做了一次 commit</li>
</ol>
</li>
</ul>


<p><img src="https://ruby-china-files.b0.upaiyun.com/photo/2014/8378188d524614d5b12bc27c42404a24.png" alt="" /></p>

<p>0c5ca 对应的 commit 对象就是生成的分支 test1 中的。分支在 Git 中是一个非常轻量化的操作，建立分支甚至都不增加新的对象。</p>

<ul>
<li><ol>
<li>第 5 次提交，这次涉及到一个合并操作，图已经变得比较复杂了</li>
</ol>
</li>
</ul>


<p><img src="https://ruby-china-files.b0.upaiyun.com/photo/2014/8e555b42a9775d725bd95ee7f369af7c.png" alt="" /></p>

<p>def18 就是合并后的 commit 对象。合并生成了一个新的commit ，这个 commit 的 parent 有两个，指向合并的两个原分支对应的 commit 上。</p>

<p>抱歉没有写得很详细，恐怕需要自己参照例子试试一看看，搞明白这些图，也就能搞明白整个 Git 对象模型机制了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用 capistrano 部署到内部服务器]]></title>
    <link href="http://xiewenwei.github.com//blog/2014/07/13/capistrano-to-servers-behind-gateway/"/>
    <updated>2014-07-13T14:44:00+08:00</updated>
    <id>http://xiewenwei.github.com//blog/2014/07/13/capistrano-to-servers-behind-gateway</id>
    <content type="html"><![CDATA[<p>capistrano 是使用方便，功能强大的自动化部署工具，它已经成为 Ruby 部署事实上的标准，薄荷项目自动化部署一直使用 capistrano。以前薄荷的服务器基本上是物理机，这些物理机都直接连接外网，最近租用了一些了云主机，为了更好的安全性，同时也为了节约成本，绝大大部分云主机并没有连接外网，只能通过一台连接外网的中转机连接。我们需要把应用部署到这些内部服务器上，最初我们使用了在中转机进行端口转发的方式，最近使用 capistrano deploy via gateway（姑且把它称为网关中转）方式，十分方便。</p>

<p>服务器部署示意图如下所示：</p>

<p><img src="http://xiewenwei.github.com//images/house/top.png" alt="服务器部署示意图" /></p>

<h2>端口转发方式</h2>

<p>端口转发方式要对中转服务器端口转发做设置，在 iptables 中配置例子如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-A PREROUTING -p tcp -m tcp --dport 10222 -j DNAT --to-destination 192.168.1.102:22</span></code></pre></td></tr></table></div></figure>


<p>端口转发实质上和 capistrano 没有直接关系，是在网络层面对中转服务器和内网实际部署服务器做了设置，让 capistrano 通过一个特定的端口与内网服务器通信，在 capistrano 看起来，内网服务器和中转服务器是一样的，只是端口不同而已。</p>

<h2>网关中转方式</h2>

<p>网关中转方式下，部署客户机首先和中转服务器建立连接，中间服务器再和内网服务器建立连接，部署工作站和内网服务器通过这两个连接通信。网关中转方式通过 capistrano 设置 deploy via gateway 选项完成，不需要对中转服务器做转发设置。</p>

<p>需要注意的是，使用网关中转方式时，capistrano 2.x 和 capistrano 3.x 差异很大，两种并不兼容。</p>

<p>capistrano 2.x 设置很简单，只要设置 gateway 选项就行了，如下所示：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'>  <span class="c1"># 实际使用中要把 &lt;user&gt; 和 &lt;gateway host&gt; 替换为真实值</span>
</span><span class='line'>  <span class="n">set</span> <span class="ss">:gateway</span><span class="p">,</span> <span class="s2">&quot;&lt;user&gt;@&lt;gateway host&gt;&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>capistrano 2.x 的设置在 capistrano 3.x 下不能工作，原因是 cap3 对网络连接做了非常大得重构，原来一些特性使用接口有变化。
capistrano 3.x 设置如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'>  <span class="nb">require</span> <span class="s1">&#39;net/ssh/proxy/command&#39;</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1"># 实际使用中要把 &lt;user&gt; 和 &lt;gateway host&gt; 替换为真实值</span>
</span><span class='line'>  <span class="n">set</span> <span class="ss">:ssh_options</span><span class="p">,</span> <span class="n">proxy</span><span class="p">:</span>
</span><span class='line'>    <span class="no">Net</span><span class="o">::</span><span class="no">SSH</span><span class="o">::</span><span class="no">Proxy</span><span class="o">::</span><span class="no">Command</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s1">&#39;ssh &lt;user&gt;@&lt;gateway host&gt; -W %h:%p&#39;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>总结：capistrano 可以通过简单的设置完成向内网服务器部署应用，有端口转发和网关中转两种方式，推荐使用网关中转方式。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redis 使用模式之一：计数器]]></title>
    <link href="http://xiewenwei.github.com//blog/2014/07/06/redis-use-pattern-1-counter/"/>
    <updated>2014-07-06T23:23:00+08:00</updated>
    <id>http://xiewenwei.github.com//blog/2014/07/06/redis-use-pattern-1-counter</id>
    <content type="html"><![CDATA[<p>Redis 是目前 NoSQL 领域的当红炸子鸡，它象一把瑞士军刀，小巧、锋利、实用，特别适合解决一些使用传统关系数据库难以解决的问题。打算写一系列 Redis 使用模式的文章，深入总结介绍 Redis 常见的使用模式，以供大家参考。</p>

<h2>常见汇总计数器</h2>

<p>汇总计数是系统常见功能，比如网站通常需要统计注册用户数，网站总浏览次数等等。
使用 Redis 提供的基本数据类型就能实现汇总计数器，通过 <code>incr</code> 命令实现增加操作。</p>

<p>比如注册用户数，基本操作命令如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  # 获取注册用户数
</span><span class='line'>  get total_users
</span><span class='line'>  # 注册用户数增加一位
</span><span class='line'>  incr total_users</span></code></pre></td></tr></table></div></figure>


<h2>按时间汇总的计数器</h2>

<p>通常计数还要按时间统计，比如注册用户数需要按日统计，处理方法比较简单，把日期带入计数器 key 就可以。</p>

<p>还是注册用户计数的例子，基本操作命令如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  # 假定操作 2014-07-06 数据
</span><span class='line'>  # 获取注册用户数
</span><span class='line'>  get total_users:2014-07-06
</span><span class='line'>  # 2014-07-06 注册用户数增加一位
</span><span class='line'>  incr total_users:2014-07-06
</span><span class='line'>  # 设置 48 小时过期时间 172800 = 48 * 60 * 60
</span><span class='line'>  expire total_users:2014-07-06 172800</span></code></pre></td></tr></table></div></figure>


<p>为计数器设置一个 48 小时的过期时间是为了节省计数器占用空间，毕竟 redis 是内存数据库，可以在过期前执行一个任务把计数器存入关系数据库。</p>

<h2>速度控制</h2>

<p>速度控制也是 Redis 一种常见的计数用途，比如有一个 API 服务，希望控制每一个 IP 每秒请求数不超过 10 次，可以用 IP 和 时间秒作为 key 设置一个计数器，实现控制，伪代码如下所示：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'>  <span class="c1"># 每秒最大请求数</span>
</span><span class='line'>  <span class="no">MAX_REQUESTS_PER_SECOND</span> <span class="o">=</span> <span class="mi">10</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1"># 检查 ip 请求限制</span>
</span><span class='line'>  <span class="c1"># @param ip</span>
</span><span class='line'>  <span class="c1"># @raise 超过限制，抛出 RuntimeError 异常</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="nf">check_request_limitation_for_ip</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span>
</span><span class='line'>    <span class="n">time_tick</span> <span class="o">=</span> <span class="no">Time</span><span class="o">.</span><span class="n">now</span><span class="o">.</span><span class="n">to_i</span>
</span><span class='line'>    <span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="n">ip</span><span class="si">}</span><span class="s2">:</span><span class="si">#{</span><span class="n">time_tick</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class='line'>    <span class="n">num</span> <span class="o">=</span> <span class="vg">$redis</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="o">.</span><span class="n">to_i</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">num</span> <span class="o">&gt;</span> <span class="no">MAX_REQUEST_PER_SECOND</span>
</span><span class='line'>      <span class="k">raise</span> <span class="s1">&#39;too many requests&#39;</span>
</span><span class='line'>    <span class="k">else</span>
</span><span class='line'>      <span class="vg">$redis</span><span class="o">.</span><span class="n">incr</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
</span><span class='line'>      <span class="vg">$redis</span><span class="o">.</span><span class="n">expire</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<h2>使用 Hash 数据类型维护大量计数器</h2>

<p>有时候需要维护大量计数器，比如每一个论坛主题的查看数，比如每一个用户访问页面次数，因为论坛主题和用户基数可能很大，直接基于论坛主题或用户 ID 生成计数器的话，占用 Redis 资源还是相当可观的，这时可以用 Hash 数据类型压缩所需资源。</p>

<p>比如，对应论坛主题查看计数，可以由模式</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'>  <span class="n">key</span><span class="p">:</span> <span class="n">topic</span><span class="p">:</span><span class="o">&lt;</span><span class="n">topic_id</span><span class="o">&gt;</span><span class="ss">:views</span>
</span><span class='line'>  <span class="n">value</span><span class="p">:</span> <span class="n">view</span> <span class="n">count</span> <span class="p">(</span><span class="n">integer</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>
转换为模式：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'>  <span class="n">key</span><span class="p">:</span> <span class="n">topic</span><span class="ss">:views</span>
</span><span class='line'>  <span class="n">value</span><span class="p">:</span> <span class="nb">hash</span>
</span><span class='line'>    <span class="nb">hash</span> <span class="n">key</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">topic_id</span><span class="o">&gt;</span>
</span><span class='line'>    <span class="nb">hash</span> <span class="n">value</span><span class="p">:</span> <span class="n">view</span> <span class="n">count</span> <span class="p">(</span><span class="n">integer</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>总结：利用 Redis 实现计数器，可以简单高效实现各种计数功能。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MongoDB 中建索引注意事项]]></title>
    <link href="http://xiewenwei.github.com//blog/2014/06/29/build-index-in-mongodb/"/>
    <updated>2014-06-29T23:42:00+08:00</updated>
    <id>http://xiewenwei.github.com//blog/2014/06/29/build-index-in-mongodb</id>
    <content type="html"><![CDATA[<p>上周在 ruby-china 上发了帖子《MongoDB 那些坑》，反映相当热烈，许多回复很有见地，其中一位童鞋深入的提到 MongoDB 建索引方法的问题，引发我更深入的了解了 MongoDB 建索引的方法和一些注意事项。</p>

<p>在 《MongoDB 那些坑》中提到，在前台直接运行建立索引命令的话，将造成整个数据库阻塞，因此索引建议使用 background 的方式建立。但是这也会带来一定的问题，在 2.6 版本之前，在 secondary server 中即使使用 background 方式建立索引，secondary 还是会以 foreground 方式建立索引，它导致 secondary 同样引发数据库阻塞问题。2.6 版本修复了这个 Bug，2.6 版之后使用 background 方式建立索引时，真正转向后台运行了。</p>

<p>为了尽量降低建立索引对 MongoDB Server 的影响，有一种方法是把 MongoDB Server 转换成 standalone 模式后建立。具体做法如下：</p>

<ol>
<li><p>首先把 secondary server 停止，在取消 <code>--replSet</code> 参数，并且更改 MongoDB port 之后重新启动 MongoDB，这时候 MongoDB 将进入 standalone 模式；</p></li>
<li><p>在 standalone 模式下运行命令 ensureIndex 建立索引，建议使用 foreground 方式运行；</p></li>
<li><p>建立索引完毕之后关闭 secondary server 按正常方式启动;</p></li>
<li><p>根据上述 1~3 的步骤轮流为 secondary 建立索引，最后把 primary server 临时转换为 secondary server，同样按 1~3 的方法建立索引，再把其转换为 primary server。</p></li>
</ol>


<p> 这种方式还是比较麻烦的，但可以把建立索引操作对 MongoDB 的影响降到最低，在有些情况下还是值得做的。</p>

<p> 参考资料：
 <a href="http://docs.mongodb.org/manual/tutorial/build-indexes-on-replica-sets/">build-indexes-on-replica-sets</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【上海】薄荷科技长期寻找靠谱的 Ruby, Web 前端，iOS 和 Android 工程师]]></title>
    <link href="http://xiewenwei.github.com//blog/2014/06/28/2014-boohee-jobs/"/>
    <updated>2014-06-28T07:57:00+08:00</updated>
    <id>http://xiewenwei.github.com//blog/2014/06/28/2014-boohee-jobs</id>
    <content type="html"><![CDATA[<h3>上海薄荷科技寻找靠谱的高级 Web 前端工程师</h3>

<ul>
<li> 工作地点：上海浦东新区张江高科技园</li>
<li> 职位：Ruby, Web 前端，iOS 和 Android 工程师（长期）</li>
<li> 职责：薄荷 App，薄荷网站和微信平台 Web 程序设计开发，架构设计，代码重构，性能优化。</li>
</ul>


<h3>我们是谁</h3>

<p>薄荷是中国领先移动健康公司，主要产品“薄荷” 是中国最受欢迎的健康健美类 App 之一，用户已近千万，长期位于 App Store 健康健美榜前列，长期位于各大 Android 应用市场健康或生活类应用前列。</p>

<p>我叫谢文威，是薄荷联合创始人，我在 2006 年底和大学同学、上下铺的兄弟马海华一起建立了薄荷。在创立薄荷之前，我曾经做过多年的程序员，DBA，数据挖掘工程师和项目经理，我在薄荷主要负责技 术。薄荷是我第一次创业，走过很多弯路，可谓屡败屡战，所幸我们顽强的生存下来，现在还算有不错的进展。</p>

<p>薄荷一直专注女性健康生活领域，我们十分信奉法国一位哲学家卢梭的一条格言 “在所有的人类知识中，最重要而又最缺乏的是关于人的知识” ，我们相信随着大数据时代，数据化自我时代的到来，基于数据应用改善人的健康和美丽方向一定大有可为。</p>

<h3>寻找什么样的人</h3>

<p>我们希望找到靠谱各领域工程师 ，一些要求如下：</p>

<ul>
<li> 1 年以上工作经验；</li>
<li> 精通所在领域相关技术，追求极致用户体验，</li>
<li> 编程基础良好，追求优雅的代码；</li>
<li> 热爱技术开发，有极客精神，参与过开源项目或常写技术博客加分哦！</li>
</ul>


<p>我们注重能力包括：</p>

<ul>
<li> 解决问题能力。自信，积极主动，做事有条理，目标导向。</li>
<li> 学习能力。乐于学习，善于总结分享，渴望每天都在进步。</li>
<li> 团队协作能力。诚实，坦率，有责任心，信任、尊重、包容。</li>
</ul>


<h3>我们能为你提供什么</h3>

<ul>
<li>发挥你能力的舞台</li>
</ul>


<p>薄荷的技术系统正处于从 数百万用户量到数千万量级 演进过程中，这里充满了机会和挑战，如果你是技术大牛，或者渴望快速成长为技术大牛，这里有供你发挥的舞台。如果想未来成为产品经理，或者自己创业，这里也将为你打下坚实的基础。</p>

<ul>
<li>优雅舒适的环境</li>
</ul>


<p>为了让你写出优雅的代码，我们当然为你提供优雅的工作环境。相比其它互联网公司，薄荷一个特点是女员工比例很高，男女比例是 1 比 2，我们有美女程序员，美女设计师，美女咨询师和美女产品经理 &#8230; 因为我们从事的是女性美丽相关的业务，我们的口号是：与美女一起共事，为美女服务！</p>

<ul>
<li>超出你预期的回报</li>
</ul>


<p>年薪 10~25 万，上不封顶，取决于你的能力和业绩。目前公司处于快速发展阶段，公司已全面盈利，并且已有顶尖美元风投基金加入（晨兴，SIG，DCM和高通），未来充满无限想象。我们将把你视为伙伴，希望通过一起努力，能够提供远超你预期的回报。</p>

<h3>联系方式</h3>

<p>如果您对我们的工作岗位感兴趣，请把您的简历或情况发邮件到vincent(at)boohee.com，最好能充分展示您的能力，谢谢！</p>

<h3>下面是我们目前的办公环境</h3>

<p><img src="http://bohetest.qiniudn.com/house.jpg" alt="薄荷的办公环境" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MongoDB 那些坑]]></title>
    <link href="http://xiewenwei.github.com//blog/2014/06/22/trap-in-mongodb/"/>
    <updated>2014-06-22T22:48:00+08:00</updated>
    <id>http://xiewenwei.github.com//blog/2014/06/22/trap-in-mongodb</id>
    <content type="html"><![CDATA[<p>MongoDB 是目前炙手可热的 NoSQL 文档型数据库，它提供的一些特性很棒：如自动 failover 机制，自动 sharding，无模式 schemaless，大部分情况下性能也很棒。但是薄荷在深入使用 MongoDB 过程中，遇到了不少问题，下面总结几个我们遇到的坑。特别申明：我们目前用的 MongoDB 版本是 2.4.10，曾经升级到 MongoDB 2.6.0 版本，问题依然存在，又回退到 2.4.10 版本。</p>

<h2>MongoDB 数据库级锁</h2>

<p><strong><em>坑爹指数：5星（最高5星）</em></strong></p>

<p>MongoDB的锁机制和一般关系数据库如 MySQL（InnoDB）, Oracle 有很大的差异，InnoDB 和 Oracle 能提供行级粒度锁，而 MongoDB 只能提供 <strong><em>库级粒度锁</em></strong>，这意味着当 MongoDB 一个写锁处于占用状态时，其它的读写操作都得干等。</p>

<p>初看起来库级锁在大并发环境下有严重的问题，但是 MongoDB 依然能够保持大并发量和高性能，这是因为 MongoDB 的锁粒度虽然很粗放，但是在锁处理机制和关系数据库锁有很大差异，主要表现在：</p>

<ul>
<li>MongoDB 没有完整事务支持，操作原子性只到单个 document 级别，所以通常操作粒度比较小；</li>
<li>MongoDB 锁实际占用时间是内存数据计算和变更时间，通常很快；</li>
<li>MongoDB 锁有一种临时放弃机制，当出现需要等待慢速 IO 读写数据时，可以先临时放弃，等 IO 完成之后再重新获取锁。</li>
</ul>


<p>通常不出问题不等于没有问题，如果数据操作不当，依然会导致长时间占用写锁，比如下面提到的前台建索引操作，当出现这种情况的时候，整个数据库就处于完全阻塞状态，无法进行任何读写操作，情况十分严重。</p>

<p>解决问题的方法，尽量避免长时间占用写锁操作，如果有一些集合操作实在难以避免，可以考虑把这个集合放到一个单独的 MongoDB 库里，因为 MongoDB 不同库锁是相互隔离的，分离集合可以避免某一个集合操作引发全局阻塞问题。</p>

<h2>建索引导致数据库阻塞</h2>

<p><strong><em>坑爹指数：3星</em></strong></p>

<p>上面提到了 MongoDB 库级锁的问题，建索引就是一个容易引起长时间写锁的问题，MongoDB 在前台建索引时需要占用一个写锁（而且不会临时放弃），如果集合的数据量很大，建索引通常要花比较长时间，特别容易引起问题。</p>

<p>解决的方法很简单，MongoDB 提供了两种建索引的访问，一种是 background 方式，不需要长时间占用写锁，另一种是非 background 方式，需要长时间占用锁。使用 background 方式就可以解决问题。
例如，为超大表 posts 建立索引，
<strong><em>千万不用使用</em></strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">db</span><span class="p">.</span><span class="nx">posts</span><span class="p">.</span><span class="nx">ensureIndex</span><span class="p">({</span><span class="nx">user_id</span><span class="o">:</span> <span class="mi">1</span><span class="p">})</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong><em>而应该使用</em></strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">db</span><span class="p">.</span><span class="nx">posts</span><span class="p">.</span><span class="nx">ensureIndex</span><span class="p">({</span><span class="nx">user_id</span><span class="o">:</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="nx">background</span><span class="o">:</span> <span class="mi">1</span><span class="p">})</span>
</span></code></pre></td></tr></table></div></figure>


<h2>不合理使用嵌入 embed document</h2>

<p><strong><em>坑爹指数：5星</em></strong></p>

<p>embed document 是 MongoDB 相比关系数据库差异明显的一个地方，可以在某一个 document 中嵌入其它子 document，这样可以在父子 document 保持在单一 collection 中，检索修改比较方便。</p>

<p>比如薄荷的应用情景中有一个 Group document，用户申请加入 Group 建模为 GroupRequest document，我们最初的时候使用 embed 方式把 GroupRequest 放置到 Group 中。
Ruby 代码如下所示（使用了 Mongoid ORM）:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">Group</span>
</span><span class='line'>  <span class="kp">include</span> <span class="no">Mongoid</span><span class="o">::</span><span class="no">Document</span>
</span><span class='line'>  <span class="o">.</span><span class="n">.</span><span class="o">.</span>
</span><span class='line'>  <span class="n">embeds_many</span> <span class="ss">:group_requests</span>
</span><span class='line'>  <span class="o">.</span><span class="n">.</span><span class="o">.</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">GroupRequest</span>
</span><span class='line'>  <span class="kp">include</span> <span class="no">Mongoid</span><span class="o">::</span><span class="no">Document</span>
</span><span class='line'>  <span class="o">.</span><span class="n">.</span><span class="o">.</span>
</span><span class='line'>  <span class="n">embedded_in</span> <span class="ss">:group</span>
</span><span class='line'>  <span class="o">.</span><span class="n">.</span><span class="o">.</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个使用方式让我们掉到坑里了，差点就爬不出来，它导致有接近两周的时间系统问题，高峰时段常有几分钟的系统卡顿，最严重一次甚至引起 MongoDB 宕机。</p>

<p>仔细分析后，发现某些活跃的 Group 的 group_requests 增加（当有新申请时）和更改（当通过或拒绝用户申请时）异常频繁，而这些操作经常长时间占用写锁，导致整个数据库阻塞。原因是当有增加 group_request 操作时，Group 预分配的空间不够，需要重新分配空间（内存和硬盘都需要），耗时较长，另外 Group 上建的索引很多，移动 Group 位置导致大量索引更新操作也很耗时，综合起来引起了长时间占用锁问题。</p>

<p>解决问题的方法，说起来也简单，就是把 embed 关联更改成的普通外键关联，就是类似关系数据库的做法，这样 group_request 增加或修改都只发生在 GroupRequest 上，简单快速，避免长时间占用写锁问题。当关联对象的数据不固定或者经常发生变化时，一定要避免使用 embed 关联，不然会死的很惨。</p>

<h2>不合理使用 Array 字段</h2>

<p><strong><em>坑爹指数：4星</em></strong></p>

<p>MongoDB 的 Array 字段是比较独特的一个特性，它可以在单个 document 里存储一些简单的一对多关系。</p>

<p>薄荷有一个应用情景使用遇到严重的性能问题，直接上代码如下所示：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">User</span>
</span><span class='line'>  <span class="kp">include</span> <span class="no">Mongoid</span><span class="o">::</span><span class="no">Document</span>
</span><span class='line'>  <span class="o">.</span><span class="n">.</span><span class="o">.</span>
</span><span class='line'>  <span class="n">field</span> <span class="ss">:follower_user_ids</span><span class="p">,</span> <span class="n">type</span><span class="p">:</span> <span class="nb">Array</span><span class="p">,</span> <span class="n">default</span><span class="p">:</span> <span class="o">[]</span>
</span><span class='line'>  <span class="o">.</span><span class="n">.</span><span class="o">.</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>User 中通过一个 Array 类型字段 follower_user_ids 保存用户关注的人的 id，用户关注的人从 10个到 3000 个不等，变化是比较频繁的，和上面 embed 引发的问题类似，频繁的 follower_user_ids 增加修改操作导致大量长时间数据库写锁，从而引发 MongoDB 数据库性能急剧下降。</p>

<p>解决问题的方法：我们把 follower_user_ids 转移到了内存数据库 redis 中，避免了频繁更改 MongoDB 中的 User, 从而彻底解决问题。如果不使用 redis，也可以建立一个 UserFollower 集合，使用外键形式关联。</p>

<p>先列举上面几个坑吧，都是害人不浅的陷阱，使用 MongoDB 过程一定要多加注意，避免掉到坑里。</p>

<p>参考资料：
  * 1.<a href="http://docs.mongodb.org/manual/faq/concurrency/">MongoDB 锁机制详解</a>
  * 2.<a href="http://docs.mongodb.org/manual/tutorial/build-indexes-in-the-background/">MongoDB 建立索引操作文档</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[保护 Redis 的数据]]></title>
    <link href="http://xiewenwei.github.com//blog/2014/06/16/redis-data-protection/"/>
    <updated>2014-06-16T00:08:00+08:00</updated>
    <id>http://xiewenwei.github.com//blog/2014/06/16/redis-data-protection</id>
    <content type="html"><![CDATA[<p>Redis 是非常流行的 key-value 类型的 NOSQL 数据库，它的 value 数据类型丰富多样，适合解决很多对关系数据库来说棘手的问题。Redis 是内存数据库，也就是说它把所有的数据都放在内存中。众所周知，当前机器突然断电或者系统异常崩溃时，内存的数据会丢失的，所以如果把系统的关键数据放在 Redis 中必须做好保护措施。</p>

<p>Redis 提供了两种持久化数据机制：</p>

<p>一种是 RDB 机制。这种方式是把当前整个 Redis 内存数据快照写到磁盘上。优点是比较简单，恢复快速。缺点是代价比较昂贵，尤其当数据量很大时，会严重影响到 Redis（照成 Redis 停顿），而且会极度消耗磁盘 IO。</p>

<p>另一种是 AppendOnly 机制。这种方式类似于 log，把数据操作命令全部存入 log 文件。优点是每段时间写入数据不是很大，可以设置很短的写入时间间隔（比如1秒钟）。缺点是 log 文件可能会远大于数据文件，通常会是数据文件大小的 3~5 倍，而且恢复的时间要远大于 RDB 方式的恢复时间。</p>

<p>这两种机制各有优劣，不过它们是可以结合起来使用的。在实际使用过程，通常还结合 Redis 的 slave 功能，做到对 Redis 影响更小，保护更充分。具体的做法是对 Redis 建立 master 和 slave，在 master 上根本不使用任何持久化机制，只在 slave 上建立结合 RDB 和 AppendOnly 的持久化机制。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[分割 Redis 实例]]></title>
    <link href="http://xiewenwei.github.com//blog/2014/06/08/sharding-redis-instance/"/>
    <updated>2014-06-08T23:59:00+08:00</updated>
    <id>http://xiewenwei.github.com//blog/2014/06/08/sharding-redis-instance</id>
    <content type="html"><![CDATA[<p>薄荷 App 上的伙伴功能大量使用了内存数据库 Redis，随着数据量的快速增长，Redis 膨胀得很快，已经接近 12 GB规模，这些数据全部放在单个 Redis 实例中。单个巨大 Redis 实例有如下几个坏处：</p>

<ol>
<li><p>首先，需要一台内存很大的机器。Redis 是内存数据库，它需要把所有需求全部放在内存中，需要为之装下 12 GB的 Redis 实例，至少需要 12 GB 内存大小的机器，考虑的预留增长空间，一般需要 12 * 1.5 约 18 GB 内存。 另外还有一个考虑的因素是，Redis 进行硬盘数据存储时，fork 进程需要消耗同样大小的内存，因此一个 12GB 的 redis 实例需要 32 GB左右的内存比较合适，这对机器提出了很高的要求，常常难以满足。</p></li>
<li><p>然后，Redis 容易成为性能瓶颈。Redis 的并发模型是单进程单线程，它不能充分利用多核 CPU，在请求数很高，或者某一些请求处理比较慢时（比如一些大的数据排序），可能会成为系统的性能瓶颈。有方法可以缓解甚至这个问题，就是建立多个 Redis 实例，通过多个 Redis 连接来实现。</p></li>
<li><p>另外，单个巨大的 Redis 实例也会增加数据管理难度，因为这么大的数据量，无论是复制，备份操作都比较慢，容易对线上系统造成冲击。</p></li>
</ol>


<p>因此，十分有必要把单个巨大的 Redis 实例分割成多个小的 Redis 实例。</p>

<p>使用 Redis 的复制机制，可以在线平滑处理 Redis 实例分割，几乎不会对系统有很大的影响。</p>

<p>分割的具体操作思路如下：</p>

<ol>
<li><p>首先，规划 Redis 分割策略，通常是基于业务划分，比如薄荷伙伴是基于业务分成 timeline, user_relationship, other 3个 Redis 实例。规划好之后，需要根据规划结果对应用程序中 Redis 程序代码做修改，通常是有一个统一的 Redis 链接修改为多个 Redis 连接，不同业务使用不同的连接。</p></li>
<li><p>然后，通过 Redis 复制功能建立多个 Redis 副本，让不同 Redis 连接使用不同的 Redis 副本，在 Redis 副本中删除多余的数据。批量删除某个模式的 keys，可以使用下面的 shell 命令：</p></li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>redis-cli KEYS "&lt;pattern&gt;" | xargs redis-cli DEL</span></code></pre></td></tr></table></div></figure>


<p><pattern> 改成实际的模式，如</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>redis-cli KEYS "user:*:followers" | xargs redis-cli DEL</span></code></pre></td></tr></table></div></figure>


<p>表示删除 user followers 数据。</p>

<ol>
<li>最后通过来回切换并重启 Redis 实例达到完全分割 Redis 实例。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ActiveSupport::Concern 的工作原理]]></title>
    <link href="http://xiewenwei.github.com//blog/2014/01/13/how-activesupport-corncern-work/"/>
    <updated>2014-01-13T00:29:00+08:00</updated>
    <id>http://xiewenwei.github.com//blog/2014/01/13/how-activesupport-corncern-work</id>
    <content type="html"><![CDATA[<p>去年有一次的周记分享过 ActiveSupport::Concern （以下简称 Concern） 的用法，但是对它的实现原理一直不太明白，周末把它的实现源码仔细研究了一番，总算比较深入了解了它的工作原理，同时也让我对 Ruby 元编程有了更深的了解。</p>

<p>Concern 主要用于解决 module mix 的依赖问题，同时简化 module mix 的步骤。
关于依赖问题，必须用一个例子才好说明：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">Foo</span>
</span><span class='line'>  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">included</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
</span><span class='line'>    <span class="n">base</span><span class="o">.</span><span class="n">class_eval</span> <span class="k">do</span>
</span><span class='line'>      <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">method_injected_by_foo</span>
</span><span class='line'>        <span class="o">.</span><span class="n">.</span><span class="o">.</span>
</span><span class='line'>      <span class="k">end</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="k">module</span> <span class="nn">Bar</span>
</span><span class='line'>  <span class="kp">include</span> <span class="no">Foo</span>
</span><span class='line'>  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">included</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
</span><span class='line'>    <span class="n">base</span><span class="o">.</span><span class="n">method_injected_by_foo</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Host</span>
</span><span class='line'>  <span class="kp">include</span> <span class="no">Foo</span> <span class="c1"># We need to include this dependency for Bar</span>
</span><span class='line'>  <span class="kp">include</span> <span class="no">Bar</span> <span class="c1"># Bar is the module that Host really needs</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面例子中 Host 为了 include Bar，必须得先 include Bar 依赖的 Foo，这是因为 Bar 在 include Foo 时，只是为 Bar extend method_injected_by_foo 方法，所以 Host 必须显式的 include Foo，才能够 extend method_injected_by_foo 方法。</p>

<p>使用 Concern 后，代码可以简写为</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">require</span> <span class="s1">&#39;active_support/concern&#39;</span>
</span><span class='line'>
</span><span class='line'><span class="k">module</span> <span class="nn">Foo</span>
</span><span class='line'>  <span class="kp">extend</span> <span class="no">ActiveSupport</span><span class="o">::</span><span class="no">Concern</span>
</span><span class='line'>  <span class="n">included</span> <span class="k">do</span>
</span><span class='line'>    <span class="nb">class_eval</span> <span class="k">do</span>
</span><span class='line'>      <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">method_injected_by_foo</span>
</span><span class='line'>        <span class="o">.</span><span class="n">.</span><span class="o">.</span>
</span><span class='line'>      <span class="k">end</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="k">module</span> <span class="nn">Bar</span>
</span><span class='line'>  <span class="kp">extend</span> <span class="no">ActiveSupport</span><span class="o">::</span><span class="no">Concern</span>
</span><span class='line'>  <span class="kp">include</span> <span class="no">Foo</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">included</span> <span class="k">do</span>
</span><span class='line'>    <span class="nb">self</span><span class="o">.</span><span class="n">method_injected_by_foo</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Host</span>
</span><span class='line'>  <span class="kp">include</span> <span class="no">Bar</span> <span class="c1"># works, Bar takes care now of its dependencies</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>Bar 和 Foo 都 <code>extend ActiveSupport::Concern</code> 后，Host include Bar 已经不需要事先 mix Foo。</p>

<p>这是怎么做到的呢，看看 Concern 的代码，其实代码很少：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span>
</span><span class='line'>  <span class="nn">module</span> <span class="no">Concern</span>
</span><span class='line'>    <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">extended</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
</span><span class='line'>      <span class="n">base</span><span class="o">.</span><span class="n">instance_variable_set</span><span class="p">(</span><span class="s2">&quot;@_dependencies&quot;</span><span class="p">,</span> <span class="o">[]</span><span class="p">)</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">append_features</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
</span><span class='line'>      <span class="k">if</span> <span class="n">base</span><span class="o">.</span><span class="n">instance_variable_defined?</span><span class="p">(</span><span class="s2">&quot;@_dependencies&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="n">base</span><span class="o">.</span><span class="n">instance_variable_get</span><span class="p">(</span><span class="s2">&quot;@_dependencies&quot;</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="nb">self</span>
</span><span class='line'>        <span class="k">return</span> <span class="kp">false</span>
</span><span class='line'>      <span class="k">else</span>
</span><span class='line'>        <span class="k">return</span> <span class="kp">false</span> <span class="k">if</span> <span class="n">base</span> <span class="o">&lt;</span> <span class="nb">self</span>
</span><span class='line'>        <span class="vi">@_dependencies</span><span class="o">.</span><span class="n">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">dep</span><span class="o">|</span> <span class="n">base</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="ss">:include</span><span class="p">,</span> <span class="n">dep</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>        <span class="k">super</span>
</span><span class='line'>        <span class="n">base</span><span class="o">.</span><span class="n">extend</span> <span class="nb">const_get</span><span class="p">(</span><span class="s2">&quot;ClassMethods&quot;</span><span class="p">)</span> <span class="k">if</span> <span class="nb">const_defined?</span><span class="p">(</span><span class="s2">&quot;ClassMethods&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="k">if</span> <span class="nb">const_defined?</span><span class="p">(</span><span class="s2">&quot;InstanceMethods&quot;</span><span class="p">)</span>
</span><span class='line'>          <span class="n">base</span><span class="o">.</span><span class="n">send</span> <span class="ss">:include</span><span class="p">,</span> <span class="nb">const_get</span><span class="p">(</span><span class="s2">&quot;InstanceMethods&quot;</span><span class="p">)</span>
</span><span class='line'>          <span class="no">ActiveSupport</span><span class="o">::</span><span class="no">Deprecation</span><span class="o">.</span><span class="n">warn</span> <span class="s2">&quot;The InstanceMethods module inside ActiveSupport::Concern will be &quot;</span> <span class="p">\</span>
</span><span class='line'>            <span class="s2">&quot;no longer included automatically. Please define instance methods directly in </span><span class="si">#{</span><span class="nb">self</span><span class="si">}</span><span class="s2"> instead.&quot;</span><span class="p">,</span> <span class="nb">caller</span>
</span><span class='line'>        <span class="k">end</span>
</span><span class='line'>        <span class="n">base</span><span class="o">.</span><span class="n">class_eval</span><span class="p">(</span><span class="o">&amp;</span><span class="vi">@_included_block</span><span class="p">)</span> <span class="k">if</span> <span class="n">instance_variable_defined?</span><span class="p">(</span><span class="s2">&quot;@_included_block&quot;</span><span class="p">)</span>
</span><span class='line'>      <span class="k">end</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">included</span><span class="p">(</span><span class="n">base</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
</span><span class='line'>      <span class="k">if</span> <span class="n">base</span><span class="o">.</span><span class="n">nil?</span>
</span><span class='line'>        <span class="vi">@_included_block</span> <span class="o">=</span> <span class="n">block</span>
</span><span class='line'>      <span class="k">else</span>
</span><span class='line'>        <span class="k">super</span>
</span><span class='line'>      <span class="k">end</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>关键部分是 <code>append_features</code> 方法，通过阅读 ruby 的文档和源码得知，ruby 在 include 一个 module 时，实际会触发两个方法，一个是 append_features，进行实际的 mixing 操作，包括增加常量，方法和变量到模块中，另外一个是 included 方法，也就是我们常用来作为 include 钩子的方法，默认的 included 是一个空方法，我们通过重载它使钩子起作用。</p>

<p>从代码可知，当一个模块 <code>extend ActiveSupport::Concern</code> 时，将产生 3 个影响：</p>

<ol>
<li>为模块设置了一个实例变量</li>
</ol>


<p>变量为 @_dependencies，其值为空数组，表示依赖的模块，将在 append_features 中用到；</p>

<ol>
<li>append_features 方法被重载；</li>
</ol>


<p>重载后行为有了很大变化，它的处理分两种情况：
一种是当它被一个有 @<em>dependencies 实例变量的模块被 include 时，直接把自身加到 @</em>dependencies 中，
比如当 Bar include Foo 时，将触发 Foo 的 append_features(base) 方法，此时 base 是 Bar，self 是 Foo，由于 Bar 已经 <code>extend ActiveSupport::Concern</code>，Bar 的 @<em>dependencies 有定义，所以直接把 Foo 加到 Bar 的 @</em>dependencies 中，然后直接返回，没有立即执行 mixing 操作。</p>

<p>当 Host include Bar 时，将触发 Bar 的 append_features(base) 方法，此时
base 是 Host，self 是 Bar，Host 没有 <code>extend ActiveSupport::Concern</code>，所以 Host 的 @<em>dependencies 无定义，将执行下面的分支，首先 include Foo（通过 Bar 的 @</em>dependencies 获得 ），然后 include Bar (通过 super)，然后是后续操作。</p>

<ol>
<li>included 方法被重载；</li>
</ol>


<p>included 的动作比较简单，如果以没有参数形式调用，将把 block 存放到 @<em>included_block 变量中，@</em>included_block 的 block 将在 append_features 方法中使用。</p>

<p>通过施加的这 3 个影响，ActiveSupport::Concern 完成了它的全部功能，非常简洁精练。</p>

<p>从中学到的东西，包括：</p>

<ol>
<li><p>module 中 append_features 和 included 方法时 include 的核心；</p></li>
<li><p>可以通过覆盖这些方法改变操作的行为；</p></li>
<li><p>可以定义模块实例变量存储属于该模块的一些数据；</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby on Rails 线程安全代码]]></title>
    <link href="http://xiewenwei.github.com//blog/2014/01/12/thread-safety-code-for-ruby-on-rails/"/>
    <updated>2014-01-12T22:52:00+08:00</updated>
    <id>http://xiewenwei.github.com//blog/2014/01/12/thread-safety-code-for-ruby-on-rails</id>
    <content type="html"><![CDATA[<p>Ruby on Rails 4.0 的 rc 版本已经 release 了，Rails 4 时代最大的变化当属默认开启多线程模式。Rails 4 的多线程将给大家带来什么好处呢？至少有两方面：</p>




<ol>
<li><p>更高的系统吞吐量
Web 站点多是 IO 密集型的，多线程可以让 Application 在等待 IO 操作的同时，还能接收处理请求，大大提升系统吞吐量，增强系统稳定性和安全性。</p></li>
<li><p>更省内存
Ruby on Rails 是内存消耗大户，一个 Applicaion 占用几百兆是常事，以前使用仅使用多进程的并发模式时，整体内存消耗巨大，使用多进程+多线程的并发模式，不单系统吞吐量大大提供，系统整体使用内存也大幅下降。</p></li>
</ol>




<p>但是天下没有免费的午餐，在享用这些好处的同时，我们也必须付出一定的代价，代价就是要应付多线程编程带来的复杂性。程序中需要处理多线程可能导致问题的地方，如果程序中出现问题也变得更加难以发现调试。</p>




<p>好在需要注意的地方也不是太多，下面把这几个需要注意的地方一一说明。</p>




<h2>代码加载</h2>




<p>Ruby 的 require 并非线程安全的，在多线程中 require，可能会导致严重的不可预期的错误。例如下面的一个演示程序在 Ruby 1.9 环境下执行会发生死锁。</p>




<p>a.rb 文件：</p>


<p><figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">puts</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="no">Thread</span><span class="o">.</span><span class="n">current</span><span class="si">}</span><span class="s2">: a.rb&quot;</span>
</span><span class='line'><span class="nb">sleep</span> <span class="mi">1</span>
</span><span class='line'><span class="nb">puts</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="no">Thread</span><span class="o">.</span><span class="n">current</span><span class="si">}</span><span class="s2">: requiring b&quot;</span>
</span><span class='line'><span class="nb">require</span> <span class="s1">&#39;b&#39;</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>b.rb 文件：</p>


<p><figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">puts</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="no">Thread</span><span class="o">.</span><span class="n">current</span><span class="si">}</span><span class="s2">: b.rb&quot;</span>
</span><span class='line'><span class="nb">puts</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="no">Thread</span><span class="o">.</span><span class="n">current</span><span class="si">}</span><span class="s2">: requiring a&quot;</span>
</span><span class='line'><span class="nb">require</span> <span class="s1">&#39;a&#39;</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>test.rb 文件：</p>


<p><figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="vg">$LOAD_PATH</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;.&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="n">t1</span> <span class="o">=</span> <span class="no">Thread</span><span class="o">.</span><span class="n">new</span> <span class="p">{</span> <span class="nb">require</span> <span class="s1">&#39;a&#39;</span> <span class="p">}</span>
</span><span class='line'><span class="n">t2</span> <span class="o">=</span> <span class="no">Thread</span><span class="o">.</span><span class="n">new</span> <span class="p">{</span> <span class="nb">require</span> <span class="s1">&#39;b&#39;</span> <span class="p">}</span>
</span><span class='line'><span class="n">t1</span><span class="o">.</span><span class="n">join</span>
</span><span class='line'><span class="n">t2</span><span class="o">.</span><span class="n">join</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>在 Ruby 1.9 环境下运行 test.rb 将报死锁错误：</p>


<p><figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c">#&lt;Thread:0x007fd2da90a268&gt;: b.rb</span>
</span><span class='line'><span class="c">#&lt;Thread:0x007fd2da90a268&gt;: requiring a</span>
</span><span class='line'><span class="c">#&lt;Thread:0x007fd2da90a2e0&gt;: a.rb</span>
</span><span class='line'><span class="c">#&lt;Thread:0x007fd2da90a2e0&gt;: requiring b</span>
</span><span class='line'>test.rb:5:in <span class="sb"><code>&lt;/span&gt;join&lt;span class="s1"&gt;&amp;#39;: deadlock detected (fatal)&lt;/span&gt;
&lt;/span&gt;&lt;span class='line'&gt;&lt;span class="s1"&gt;  from test.rb:5:in</code>&lt;main&gt;&#39;</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>因为 Ruby require 不是线程安全的，所以 Rails 中使用多线程环境时，需要对 require 做一定的限制，简单的说就是在 Application 启动的时候，把所有需要加载的代码全部加载完成，避免启动后还 require。Rails 4 的生产环境配置中该选项已经默认生效。需要注意的时，如果你的代码不在 Rails 默认的几个目录中，你需要手动配置你的目录进入 eager_load_path，例如：</p>


<p><figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">config</span><span class="o">.</span><span class="n">eager_load_paths</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="no">Rails</span><span class="o">.</span><span class="n">root</span><span class="si">}</span><span class="s2">/lib&quot;</span>
</span></code></pre></td></tr></table></div></figure></p>

<h2>全局变量和类变量写操作</h2>




<p>在 Rails 多线程环境，所有的全局变量（包括 $var @@var 和 类实例变量），在实例方法中都应该是只读的，尽量应该避免写操作。</p>




<p>下面是一个在实例方法中写类变量导致问题的例子：</p>


<p><figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">HomeController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>
</span><span class='line'>  <span class="n">before_filter</span> <span class="ss">:set_site</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="nf">index</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="kp">private</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="nf">set_site</span>
</span><span class='line'>    <span class="vi">@site</span> <span class="o">=</span> <span class="no">Site</span><span class="o">.</span><span class="n">find_by_subdomain</span><span class="p">(</span><span class="n">request</span><span class="o">.</span><span class="n">subdomains</span><span class="o">.</span><span class="n">first</span><span class="p">)</span>
</span><span class='line'>    <span class="k">if</span> <span class="vi">@site</span><span class="o">.</span><span class="n">layout?</span>
</span><span class='line'>      <span class="nb">self</span><span class="o">.</span><span class="n">class</span><span class="o">.</span><span class="n">layout</span><span class="p">(</span><span class="vi">@site</span><span class="o">.</span><span class="n">layout_name</span><span class="p">)</span>
</span><span class='line'>    <span class="k">else</span>
</span><span class='line'>      <span class="nb">self</span><span class="o">.</span><span class="n">class</span><span class="o">.</span><span class="n">layout</span><span class="p">(</span><span class="s1">&#39;default_lay&#39;</span><span class="p">)</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>上面代码的意图是根据域名设置不同的 layout。<code>self.class.layout(value)</code> 中，Rails 把 value 保存在类变量 <code>@@layout_</code>，然后在 render 的时候使用。</p>




<p>设想这样一种情况 UserA 的 subdomain 是 foo1，他的 layout 应该是 foo1，
UserB 的 subdomain 是 foo2，他的 layout 应该是 foo2。</p>




<p>UserA 和 UserB 同时请求应用，他们的请求分别在 Thread1 和 Thread2 中执行，执行顺序可能是：</p>




<ol>
<li>Thread1, 执行进入 set_site 方法，设置 <code>@@layout_</code> 为 foo1；</li>
<li>Thread2, 执行进入 set_site 方法，设置 <code>@@layout_</code> 为 foo2；</li>
<li>Thread1, render response，使用最新的 <code>@@layout_</code> foo2 render；</li>
<li>Thread2，render response，使用最新的 <code>@@layout_</code> foo2 render；</li>
</ol>




<p>我们期望 Thread1 使用 foo1 layout render，这样的执行结果和期望的不相符。</p>




<p>线程安全的写法是：</p>


<p><figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">HomeController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>
</span><span class='line'>  <span class="n">before_filter</span> <span class="ss">:set_site</span>
</span><span class='line'>  <span class="n">layout</span> <span class="ss">:site_layout</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="nf">index</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="kp">private</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="nf">set_site</span>
</span><span class='line'>    <span class="vi">@site</span> <span class="o">=</span> <span class="no">Site</span><span class="o">.</span><span class="n">find_by_subdomain</span><span class="p">(</span><span class="n">request</span><span class="o">.</span><span class="n">subdomains</span><span class="o">.</span><span class="n">first</span><span class="p">)</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="nf">site_layout</span>
</span><span class='line'>    <span class="k">if</span> <span class="vi">@site</span><span class="o">.</span><span class="n">layout?</span>
</span><span class='line'>      <span class="vi">@site</span><span class="o">.</span><span class="n">layout_name</span>
</span><span class='line'>    <span class="k">else</span>
</span><span class='line'>      <span class="s1">&#39;default_lay&#39;</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>程序在每次需要使用 layout 时，调用实例方法 <code>site_layout</code>，避免写类变量。</p>




<h2>IO Connection</h2>




<p>Rails 应用通常会用到多个 IO Connection，比如 ActiveRecord 的数据库 Connection，缓存 Memcached 的 Connection，Redis 的 Connection 等等。这些 IO Connection 在 Rails 多线程环境下并不都是线程安全的。</p>




<p>ActiveRecord 的 Connection 是线程安全的，而且 ActiveRecord 还可配置 Connection Pool，这样可以更高效率的利用数据库连接。</p>




<p>Memcached 的 Connection memchached-client 并不是线程安全的，最新的 dalli 是线程安全的。不过 dalli 的线程安全机制是在每个读写操作时加上互斥信号控制，这意味着同一时间只有一个线程可以操作，如果操作非常频繁的话，可能有性能上的问题，这个时候可以使用一个单独的 Connection Pool Gem 解决。</p>




<p>这个 Connection Pool Gem 的地址是 https://github.com/mperham/connection_pool。</p>




<p>Redis 的 Connection 和 dalli 类似，本身通过加上互斥信号控制保证线程安全，可以通过 Connection Pool 增强效率。</p>




<h2>使用互斥信号控制非线程安全操作</h2>




<p>在程序中，如果存在某些不希望多个线程同时执行的操作，可以使用互斥信号控制其执行，这样当已经有一个线程进入执行时，其他进入的 thread 都会被 block 住，等前面的进程执行结束后才会进入执行，从而保证在一个时间只有一个线程会执行。</p>




<p>示例代码如下：</p>


<p><figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">HomeController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>
</span><span class='line'>  <span class="vc">@@lock</span> <span class="o">=</span> <span class="no">Mutex</span><span class="o">.</span><span class="n">new</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="nf">index</span>
</span><span class='line'>    <span class="vc">@@lock</span><span class="o">.</span><span class="n">synchronize</span> <span class="k">do</span>
</span><span class='line'>      <span class="n">thread_unsafe_code</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="kp">private</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="nf">thread_unsafe_code</span>
</span><span class='line'>    <span class="k">if</span> <span class="vc">@@something</span> <span class="o">==</span> <span class="s1">&#39;hello&#39;</span>
</span><span class='line'>      <span class="n">do_hello</span>
</span><span class='line'>    <span class="k">elsif</span> <span class="vc">@@something</span> <span class="o">==</span> <span class="s1">&#39;world&#39;</span>
</span><span class='line'>      <span class="n">do_world</span>
</span><span class='line'>    <span class="k">else</span>
</span><span class='line'>      <span class="vc">@@something</span> <span class="o">=</span> <span class="s1">&#39;nothing&#39;</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>总之，Rails 的多线程为我们提供了简便的提升系统伸缩性的能力，这也意味的程序复杂性的增加，有几处地方使我们需要注意的，只有这样才能很好的利用 Rails 多线程能力。</p>




<p>参考：</p>




<ul>
<li><a href="http://m.onkey.org/thread-safety-for-your-rails/">http://m.onkey.org/thread-safety-for-your-rails/</a></li>
<li><a href="http://blog.headius.com/2008/08/qa-what-thread-safe-rails-means.html/">http://blog.headius.com/2008/08/qa-what-thread-safe-rails-means.html/</a></li>
<li><a href="http://tenderlovemaking.com/2012/06/18/removing-config-threadsafe.html/">http://tenderlovemaking.com/2012/06/18/removing-config-threadsafe.html/</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[多 Ruby 版本和 多 Gem 版本测试]]></title>
    <link href="http://xiewenwei.github.com//blog/2014/01/05/multiple-rubies-and-gems-test-solution/"/>
    <updated>2014-01-05T22:58:00+08:00</updated>
    <id>http://xiewenwei.github.com//blog/2014/01/05/multiple-rubies-and-gems-test-solution</id>
    <content type="html"><![CDATA[<p>admin_gateway 是用于我们所有后台统一认证和授权的组件，而我们后台程序运行在多个 Ruby 版本上，主要是 Ruby 1.9.3 和 2.0，Ruby 2.1 也已经发布了，很快也需要提供 Ruby 2.1 的支持，另外 Rails 版本有 3.0，3.2 和 4.0 三大主要版本，因此一个完整的测试方案是需要包括这 3 * 3 = 9 种组合才行。</p>

<p>首先是多个 Ruby 版本测试。这个问题比较简单，我们现在的 Ruby 环境通常是由 RVM 管理的，RVM 可以很容易的以多个 Ruby 版本重复执行 Ruby 程序，比如下面的例子：
<code>rvm ruby-1.9.3,ruby-2.0.0,ruby-2.1.0 exec ruby -e "puts RUBY_VERSION"</code>
如果运行的机器安装了这3个版本的 Ruby 的话，就会依次执行打出各自的 Ruby 版本号。
所以下面的命令就可以依次运行3个Ruby版本的测试了：</p>

<p><code>rvm ruby-1.9.3,ruby-2.0.0,ruby-2.1.0 exec bundle install</code>
<code>rvm ruby-1.9.3,ruby-2.0.0,ruby-2.1.0 exec bundle exec rake test</code></p>

<p>解决多 Ruby 版本测试的问题，然后就是多 Rails 版本测试的问题。admin_gateway 这个 gem 是一个 Rails Engine，因此需要依赖 Rails。多 Rails 版本测试意味着 test 的 gem 环境是不同的，而现在 gem 环境是由 bundle 管理的，运行 bundle 命令时可以手动指定 Gemfile 文件，因此 建立多个 Gemfile 文件，重复上面的命令就可以了，例如可以建立 rails_4_0.gemfile 这个 Gemfile，然后通过命令
<code>bundle install --gemfile rails_4_0.gemfile</code>
执行 gem 环境安装，
然后通过命令：
<code>BUNDLE_GEMFILE=rails_4_0.gemfile bundle exec rake test</code>
执行测试。</p>

<p>组合上面的方法，可以形成一个完整的多 Ruby 版本和 Rails 版本的解决方案：
1. 首先根据需要安装多个 Ruby 版本，如 ruby 1.9.3, 2.0.0 和 2.1.0，根据需要生成多个 gemfile，如 rails_3_0.gemfile, rails_3_2.gemfile 和 rails_4_0.gemfile
2. 然后使用下面的 shell 安装 gem 环境和运行测试。
<code>rvm ruby-1.9.3,ruby-2.0.0,ruby-2.1.0 exec bundle install --gemfile=rails_3_0.gemfile</code>
<code>BUNDLE_GEMFILE=rails_3_0.gemfile rvm ruby-1.9.3,ruby-2.0.0,ruby-2.1.0 exec bundle exec rake test</code>
3.2 和 4.0的类似，就不重复了。</p>

<p>解决 gem 多版本的方法有一点不干净，因为 gemfile 有很多重复内容，shell命令也比较重复，因此有一个 gem 叫 appraise （https://github.com/cfedermann/Appraise）就是用于解决这个问题，它只需要配置一个 Appraisals 文件，在 Appraisals 声明不同的 gem 依赖就可以了，比如 admin_gateway 的 Appraisals 内容如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>appraise "rails-3-0" do
</span><span class='line'>  gem "rails", "3.0.20"
</span><span class='line'>end
</span><span class='line'>
</span><span class='line'>appraise "rails-3-2" do
</span><span class='line'>  gem "rails", "3.2.16"
</span><span class='line'>end
</span><span class='line'>
</span><span class='line'>appraise "rails-4-0" do
</span><span class='line'>  gem "rails", "4.0.0"
</span><span class='line'>end</span></code></pre></td></tr></table></div></figure>


<p>然后就可以通过 rake appraisal 完成多个 rails 版本测试，它的原理和上面提到的完全一样。</p>

<p>总之，多 Ruby 版本和多 gem 版本的测试并不难，利用 rvm 和 bundle 一些特性可以快速做到，利用 appraisal 可以让其更简化。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一种轻量的移动应用离线操作和数据同步策略]]></title>
    <link href="http://xiewenwei.github.com//blog/2013/06/03/a-lightweight-offline-operation-and-data-synchronization-policy/"/>
    <updated>2013-06-03T22:58:00+08:00</updated>
    <id>http://xiewenwei.github.com//blog/2013/06/03/a-lightweight-offline-operation-and-data-synchronization-policy</id>
    <content type="html"><![CDATA[<p>对移动应用而言，离线操作和数据同步是一件烦人的事情，组合使用本地数据，远程数据缓存和服务请求暂存的策略，可以使之变得比较轻松简单。</p>




<h2>使用本地数据</h2>




<p>为了 app 在离线状态下部分功能依然能够使用，可以把部分数据直接和应用打包在一起发布。这样当应用检测到网络不通时，可以使用本地数据。比如对于食物查询功能，在网络通的时候是请求服务器完成查询的，当网络不通时，就使用本地的数据做查询。使用本地数据有两个制约，一是本地数据不能太大，太大的话应用打包后的体积会很大；二是本地数据的功能有所限制。比如对于食物查询而言，通过请求服务器完成时可以使用比较智能的搜索，使用本地查询的化就只能使用简单的文本匹配了。所以在离线操作时，需要提示用户使用的是本地数据，功能所限，联网使用的话才能使用完整功能。</p>




<h2>远程数据缓存</h2>




<p>因为本地数据有很多限制，数量不全，然后内容也不全，使用远程数据缓存可以减轻本地数据的限制。比如，食物数据只包括了最基本的名称和单位热量数据，没有包括额外的介绍、评价等数据。但是用户已经查询的食物数据可以缓存起来，离线操作查询的时候也可以显示这些信息。另外，缓存数据的一大好处是能大幅提高应用的性能。毕竟大部分操作是以读为主的，数据的变化也不是很频繁，如果利用缓存的话，能够大幅减少请求次数和网络带宽。</p>




<h2>暂存数据操作请求</h2>




<p>对于写请求的操作，在离线的时候，可以简单的把整个请求 URL 和 参数先保存起来，等到网络通了只会，再依次按顺序发送给服务器完成操作。这种方法，对比应用和服务器之间互相跟踪数据变化记录，然后根据变化记录操作数据的方法，要简单得多，而且如果中间出现问题，故障处理也要简单可靠的多。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[实例说明 Ruby 多线程的潜力和弱点]]></title>
    <link href="http://xiewenwei.github.com//blog/2013/05/25/ruby-multiple-threads-potential-and-weakness/"/>
    <updated>2013-05-25T22:52:00+08:00</updated>
    <id>http://xiewenwei.github.com//blog/2013/05/25/ruby-multiple-threads-potential-and-weakness</id>
    <content type="html"><![CDATA[<p>Web 应用大多是 IO 密集型的，利用 Ruby 多进程+多线程模型将能大幅提升系统吞吐量。其原因在于：当Ruby 某个线程处于 IO Block 状态时，其它的线程还可以继续执行。但由于存在 Ruby GIL (Global Interpreter Lock)，MRI Ruby 并不能真正利用多线程进行并行计算。JRuby 去除了 GIL，是真正意义的多线程，既能应付 IO Block，也能充分利用多核 CPU 加快整体运算速度。</p>




<p>上面说得比较抽象，下面就用例子一一加以说明。</p>




<h2>Ruby 多线程和 IO Block</h2>




<p>先看下面一段代码（演示目的，没有实际用途）：</p>


<p><figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># File: block_io1.rb</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">func1</span>
</span><span class='line'>  <span class="nb">puts</span> <span class="s2">&quot;sleep 3 seconds in func1</span><span class="se">\n</span><span class="s2">&quot;</span>
</span><span class='line'>  <span class="nb">sleep</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">func2</span>
</span><span class='line'>  <span class="nb">puts</span> <span class="s2">&quot;sleep 2 seconds in func2</span><span class="se">\n</span><span class="s2">&quot;</span>
</span><span class='line'>  <span class="nb">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">func3</span>
</span><span class='line'>  <span class="nb">puts</span> <span class="s2">&quot;sleep 5 seconds in func3</span><span class="se">\n</span><span class="s2">&quot;</span>
</span><span class='line'>  <span class="nb">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="n">func1</span>
</span><span class='line'><span class="n">func2</span>
</span><span class='line'><span class="n">func3</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>代码很简单，3 个方法，用 sleep 模拟耗时的 IO 操作。
运行代码（环境 MRI Ruby 1.9.3） 结果是：</p>


<p><figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="err">$</span> <span class="n">time</span> <span class="n">ruby</span> <span class="n">block_io1</span><span class="o">.</span><span class="n">rb</span>
</span><span class='line'><span class="nb">sleep</span> <span class="mi">3</span> <span class="n">seconds</span> <span class="k">in</span> <span class="n">func1</span>
</span><span class='line'><span class="nb">sleep</span> <span class="mi">2</span> <span class="n">seconds</span> <span class="k">in</span> <span class="n">func2</span>
</span><span class='line'><span class="nb">sleep</span> <span class="mi">5</span> <span class="n">seconds</span> <span class="k">in</span> <span class="n">func3</span>
</span><span class='line'>
</span><span class='line'><span class="n">real</span>  <span class="mi">0</span><span class="n">m11</span><span class="o">.</span><span class="mi">681</span><span class="n">s</span>
</span><span class='line'><span class="n">user</span>  <span class="mi">0</span><span class="n">m3</span><span class="o">.</span><span class="mi">086</span><span class="n">s</span>
</span><span class='line'><span class="n">sys</span> <span class="mi">0</span><span class="n">m0</span><span class="o">.</span><span class="mi">152</span><span class="n">s</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>比较慢，时间都耗在 sleep 上了，总共花了 10 多秒。</p>




<p>采用多线程的方式，改写如下：</p>


<p><figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># File: block_io2.rb</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">func1</span>
</span><span class='line'>  <span class="nb">puts</span> <span class="s2">&quot;sleep 3 seconds in func1</span><span class="se">\n</span><span class="s2">&quot;</span>
</span><span class='line'>  <span class="nb">sleep</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">func2</span>
</span><span class='line'>  <span class="nb">puts</span> <span class="s2">&quot;sleep 2 seconds in func2</span><span class="se">\n</span><span class="s2">&quot;</span>
</span><span class='line'>  <span class="nb">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">func3</span>
</span><span class='line'>  <span class="nb">puts</span> <span class="s2">&quot;sleep 5 seconds in func3</span><span class="se">\n</span><span class="s2">&quot;</span>
</span><span class='line'>  <span class="nb">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="n">threads</span> <span class="o">=</span> <span class="o">[]</span>
</span><span class='line'><span class="n">threads</span> <span class="o">&lt;&lt;</span> <span class="no">Thread</span><span class="o">.</span><span class="n">new</span> <span class="p">{</span> <span class="n">func1</span> <span class="p">}</span>
</span><span class='line'><span class="n">threads</span> <span class="o">&lt;&lt;</span> <span class="no">Thread</span><span class="o">.</span><span class="n">new</span> <span class="p">{</span> <span class="n">func2</span> <span class="p">}</span>
</span><span class='line'><span class="n">threads</span> <span class="o">&lt;&lt;</span> <span class="no">Thread</span><span class="o">.</span><span class="n">new</span> <span class="p">{</span> <span class="n">func3</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">threads</span><span class="o">.</span><span class="n">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">t</span><span class="o">|</span> <span class="n">t</span><span class="o">.</span><span class="n">join</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>运行的结果是：</p>


<p><figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="err">$</span> <span class="n">time</span> <span class="n">ruby</span> <span class="n">block_io2</span><span class="o">.</span><span class="n">rb</span>
</span><span class='line'><span class="nb">sleep</span> <span class="mi">3</span> <span class="n">seconds</span> <span class="k">in</span> <span class="n">func1</span>
</span><span class='line'><span class="nb">sleep</span> <span class="mi">2</span> <span class="n">seconds</span> <span class="k">in</span> <span class="n">func2</span>
</span><span class='line'><span class="nb">sleep</span> <span class="mi">5</span> <span class="n">seconds</span> <span class="k">in</span> <span class="n">func3</span>
</span><span class='line'>
</span><span class='line'><span class="n">real</span>  <span class="mi">0</span><span class="n">m6</span><span class="o">.</span><span class="mi">543</span><span class="n">s</span>
</span><span class='line'><span class="n">user</span>  <span class="mi">0</span><span class="n">m3</span><span class="o">.</span><span class="mi">169</span><span class="n">s</span>
</span><span class='line'><span class="n">sys</span> <span class="mi">0</span><span class="n">m0</span><span class="o">.</span><span class="mi">147</span><span class="n">s</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>总共花了 6 秒多，明显快了许多，只比最长的 sleep 5 秒多了一点。</p>




<p>上面的例子说明，<strong>Ruby 的多线程能够应付 IO Block，当某个线程处于 IO Block 状态时，其它的线程还可以继续执行，从而使整体处理时间大幅缩短</strong>。</p>




<h2>Ruby GIL 的影响</h2>




<p>还是先看一段代码（演示目的）：</p>


<p><figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># File: gil1.rb</span>
</span><span class='line'>
</span><span class='line'><span class="nb">require</span> <span class="s1">&#39;securerandom&#39;</span>
</span><span class='line'><span class="nb">require</span> <span class="s1">&#39;zlib&#39;</span>
</span><span class='line'>
</span><span class='line'><span class="n">data</span> <span class="o">=</span> <span class="no">SecureRandom</span><span class="o">.</span><span class="n">hex</span><span class="p">(</span><span class="mi">4096000</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="mi">16</span><span class="o">.</span><span class="n">times</span> <span class="p">{</span> <span class="no">Zlib</span><span class="o">::</span><span class="no">Deflate</span><span class="o">.</span><span class="n">deflate</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>代码先随机生成一些数据，然后对其进行压缩，压缩是非常耗 CPU 的，在我机器(双核 CPU, MRI Ruby 1.9.3)运行结果如下：</p>


<p><figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="err">$</span> <span class="n">time</span> <span class="n">ruby</span> <span class="n">gil1</span><span class="o">.</span><span class="n">rb</span>
</span><span class='line'>
</span><span class='line'><span class="n">real</span>  <span class="mi">0</span><span class="n">m8</span><span class="o">.</span><span class="mi">572</span><span class="n">s</span>
</span><span class='line'><span class="n">user</span>  <span class="mi">0</span><span class="n">m8</span><span class="o">.</span><span class="mi">359</span><span class="n">s</span>
</span><span class='line'><span class="n">sys</span> <span class="mi">0</span><span class="n">m0</span><span class="o">.</span><span class="mi">102</span><span class="n">s</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>更改为多线程版本，代码如下：</p>


<p><figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># File: gil2.rb</span>
</span><span class='line'>
</span><span class='line'><span class="nb">require</span> <span class="s1">&#39;securerandom&#39;</span>
</span><span class='line'><span class="nb">require</span> <span class="s1">&#39;zlib&#39;</span>
</span><span class='line'>
</span><span class='line'><span class="n">data</span> <span class="o">=</span> <span class="no">SecureRandom</span><span class="o">.</span><span class="n">hex</span><span class="p">(</span><span class="mi">4096000</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">threads</span> <span class="o">=</span> <span class="o">[]</span>
</span><span class='line'><span class="mi">16</span><span class="o">.</span><span class="n">times</span> <span class="k">do</span>
</span><span class='line'>  <span class="n">threads</span> <span class="o">&lt;&lt;</span> <span class="no">Thread</span><span class="o">.</span><span class="n">new</span> <span class="p">{</span> <span class="no">Zlib</span><span class="o">::</span><span class="no">Deflate</span><span class="o">.</span><span class="n">deflate</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="n">threads</span><span class="o">.</span><span class="n">each</span> <span class="p">{</span><span class="o">|</span><span class="n">t</span><span class="o">|</span> <span class="n">t</span><span class="o">.</span><span class="n">join</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>多线程的版本运行结果如下：</p>


<p><figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="err">$</span> <span class="n">time</span> <span class="n">ruby</span> <span class="n">gil2</span><span class="o">.</span><span class="n">rb</span>
</span><span class='line'>
</span><span class='line'><span class="n">real</span>  <span class="mi">0</span><span class="n">m8</span><span class="o">.</span><span class="mi">616</span><span class="n">s</span>
</span><span class='line'><span class="n">user</span>  <span class="mi">0</span><span class="n">m8</span><span class="o">.</span><span class="mi">377</span><span class="n">s</span>
</span><span class='line'><span class="n">sys</span> <span class="mi">0</span><span class="n">m0</span><span class="o">.</span><span class="mi">211</span><span class="n">s</span>
</span></code></pre></td></tr></table></div></figure></p>

<p> 从结果可以看出，由于 MRI Ruby GIL 的存在，Ruby 多线程并不能重复利用多核 CPU，使用多线程后整体所花时间并不缩短，反而由于线程切换的影响，所花时间还略有增加。</p>




<h2>JRuby 去除了 GIL</h2>




<p>使用 JRuby (我的机器上是 JRuby 1.7.0)运行 gil1.rb 和 gil2.rb，得到很不一样的结果。</p>


<p><figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="err">$</span> <span class="n">time</span> <span class="n">jruby</span> <span class="n">gil1</span><span class="o">.</span><span class="n">rb</span>
</span><span class='line'>
</span><span class='line'><span class="n">real</span>  <span class="mi">0</span><span class="n">m12</span><span class="o">.</span><span class="mi">225</span><span class="n">s</span>
</span><span class='line'><span class="n">user</span>  <span class="mi">0</span><span class="n">m14</span><span class="o">.</span><span class="mo">060</span><span class="n">s</span>
</span><span class='line'><span class="n">sys</span> <span class="mi">0</span><span class="n">m0</span><span class="o">.</span><span class="mi">615</span><span class="n">s</span>
</span></code></pre></td></tr></table></div></figure></p>

<p><figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="err">$</span> <span class="n">time</span> <span class="n">jruby</span> <span class="n">gil2</span><span class="o">.</span><span class="n">rb</span>
</span><span class='line'>
</span><span class='line'><span class="n">real</span>  <span class="mi">0</span><span class="n">m7</span><span class="o">.</span><span class="mi">584</span><span class="n">s</span>
</span><span class='line'><span class="n">user</span>  <span class="mi">0</span><span class="n">m22</span><span class="o">.</span><span class="mi">822</span><span class="n">s</span>
</span><span class='line'><span class="n">sys</span> <span class="mi">0</span><span class="n">m0</span><span class="o">.</span><span class="mi">819</span><span class="n">s</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>可以看到，JRuby 使用多线程时，整体运行时间有明显缩短（7.58 比 12.22），这是由于 JRuby 去除了 GIL，可以真正并行的执行多线程，充分利用了多核 CPU。</p>




<p>总结：<strong>Ruby 多线程可以在某个线程 IO Block 时，依然能够执行其它线程，从而降低 IO Block 对整体的影响，但由于 MRI Ruby GIL 的存在，MRI Ruby 并不是真正的并行执行，JRuby 去除了 GIL，可以做到真正的多线程并行执行</strong>。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby 2.0的新特性，用例子说明]]></title>
    <link href="http://xiewenwei.github.com//blog/2013/05/05/new-features-of-ruby-2-dot-0/"/>
    <updated>2013-05-05T22:52:00+08:00</updated>
    <id>http://xiewenwei.github.com//blog/2013/05/05/new-features-of-ruby-2-dot-0</id>
    <content type="html"><![CDATA[<p>Ruby 2.0 发布已经有一段时间了，之前从各种报道上大概了解到它的一些主要特性，但是没有认真仔细研究，所以印象并不深。这个周末好好研究了一番，写下这篇 Blog，算是这次学习的笔记。</p>




<p>Ruby 2.0 升级变动并不是很大，至少比 Ruby 1.8 到 1.9 的变动小，之所以把版本号定为 2.0，是为了纪念 Ruby 诞生 20 周年，所以特意选择了 Ruby 诞生 20 周日的日子 &#8211; 2013年2月24日发布。</p>




<p>虽然说变化不是特别大，但是新的特性还是挺让人兴奋的，因为它们对开发带来不少便利，让 Ruby 变得越来越性感。主要的新特性有 4 个，下面一一讲解。</p>




<h2>1. Keyword Arguments</h2>




<p><code>Keyword Arguments</code> 特性让 Ruby 2.0 开始支持关键字参数，这对处理有默认值的参数带来非常大的便利。相比于以前使用 Hash 传值方法，Keyword Arguments 可以让代码更直观简洁。</p>




<p>例子1：</p>


<p><figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Ruby 1.9:</span>
</span><span class='line'>  <span class="c1"># (From action_view/helpers/text_helper.rb)</span>
</span><span class='line'><span class="k">def</span> <span class="nf">cycle</span><span class="p">(</span><span class="n">first_value</span><span class="p">,</span> <span class="o"><em></span><span class="n">values</span><span class="p">)</span>
</span><span class='line'>  <span class="n">options</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">extract_options!</span>
</span><span class='line'>  <span class="nb">name</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">fetch</span><span class="p">(</span><span class="ss">:name</span><span class="p">,</span> <span class="s1">&#39;default&#39;</span><span class="p">)</span>
</span><span class='line'>  <span class="c1"># ...</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Ruby 2.0:</span>
</span><span class='line'><span class="k">def</span> <span class="nf">cycle</span><span class="p">(</span><span class="n">first_value</span><span class="p">,</span> <span class="o"></em></span><span class="n">values</span><span class="p">,</span> <span class="nb">name</span><span class="p">:</span> <span class="s1">&#39;default&#39;</span><span class="p">)</span>
</span><span class='line'>  <span class="c1"># ...</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>例子2：</p>


<p><figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Ruby 1.9</span>
</span><span class='line'><span class="k">def</span> <span class="nf">render</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">opts</span> <span class="o">=</span> <span class="p">{})</span>
</span><span class='line'>  <span class="n">opts</span> <span class="o">=</span> <span class="p">{</span><span class="n">fmt</span><span class="p">:</span> <span class="s1">&#39;html&#39;</span><span class="p">}</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">opts</span><span class="p">)</span>
</span><span class='line'>  <span class="n">r</span> <span class="o">=</span> <span class="no">Renderer</span><span class="o">.</span><span class="n">for</span><span class="p">(</span><span class="n">opts</span><span class="o">[</span><span class="ss">:fmt</span><span class="o">]</span><span class="p">)</span>
</span><span class='line'>  <span class="n">r</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Ruby 2.0</span>
</span><span class='line'><span class="k">def</span> <span class="nf">render</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">fmt</span><span class="p">:</span> <span class="s1">&#39;html&#39;</span><span class="p">)</span>
</span><span class='line'>  <span class="n">r</span> <span class="o">=</span> <span class="no">Renderer</span><span class="o">.</span><span class="n">for</span><span class="p">(</span><span class="n">fmt</span><span class="p">)</span>
</span><span class='line'>  <span class="n">r</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>例子3：</p>


<p><figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Ruby 1.9</span>
</span><span class='line'><span class="k">def</span> <span class="nf">accepts_nested_attributes_for</span><span class="p">(</span><span class="o"><em></span><span class="n">attr_names</span><span class="p">)</span>
</span><span class='line'>  <span class="n">options</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>    <span class="ss">:allow_destroy</span> <span class="o">=&gt;</span> <span class="kp">false</span><span class="p">,</span>
</span><span class='line'>    <span class="ss">:update_only</span> <span class="o">=&gt;</span> <span class="kp">false</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="n">options</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">attr_names</span><span class="o">.</span><span class="n">extract_options!</span><span class="p">)</span>
</span><span class='line'>  <span class="n">options</span><span class="o">.</span><span class="n">assert_valid_keys</span><span class="p">(</span>
</span><span class='line'>    <span class="ss">:allow_destroy</span><span class="p">,</span>
</span><span class='line'>    <span class="ss">:reject_if</span><span class="p">,</span>
</span><span class='line'>    <span class="ss">:limit</span><span class="p">,</span>
</span><span class='line'>    <span class="ss">:update_only</span>
</span><span class='line'>  <span class="p">)</span>
</span><span class='line'>  <span class="c1"># ...</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Ruby 2.0</span>
</span><span class='line'><span class="k">def</span> <span class="nf">accepts_nested_attributes_for</span><span class="p">(</span><span class="o"></em></span><span class="n">attr_names</span><span class="p">,</span>
</span><span class='line'>  <span class="n">allow_destroy</span><span class="p">:</span> <span class="kp">false</span><span class="p">,</span>
</span><span class='line'>  <span class="n">update_only</span><span class="p">:</span> <span class="kp">false</span>
</span><span class='line'>  <span class="n">reject_if</span><span class="p">:</span> <span class="kp">nil</span><span class="p">,</span>
</span><span class='line'>  <span class="n">limit</span><span class="p">:</span> <span class="kp">nil</span>
</span><span class='line'><span class="p">)</span>
</span><span class='line'> <span class="c1"># ...</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure></p>

<h2>2. Refinement</h2>




<p>Refinement 的目标是通过减少补丁的应用范围使打动态补丁（monkey patching）更为安全。下面是由Matz给出的一个例子，MathN模块包含进来之后“/”操作符才能在Fixnum上使用：</p>


<p><figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">MathN</span>
</span><span class='line'>  <span class="n">refine</span> <span class="no">Fixnum</span> <span class="k">do</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">/</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="n">quo</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Foo</span>
</span><span class='line'>  <span class="n">using</span> <span class="no">MathN</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="nf">foo</span>
</span><span class='line'>    <span class="nb">p</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">2</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>Rails 中有不少对 Ruby 的 monkey patching，使用 Refinement 特性重写的话可以让这些代码更安全。
但是目前 Refinement 还不是很成熟，属于体验特性，所以最好不要在生产环境使用。</p>




<h2>3. Module Prepend</h2>




<p><code>Module Prepend</code> 特性让常见的 alias_method patten 扩展一个已用方法的写法变得简洁不少。
例如，下面的代码想对 Template 的 render 方法扩展计时钩子，使用 Ruby 1.9 的写法非常臃肿。</p>


<p><figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">Template</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">erb</span><span class="p">)</span>
</span><span class='line'>    <span class="vi">@erb</span> <span class="o">=</span> <span class="n">erb</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">render</span> <span class="n">values</span>
</span><span class='line'>    <span class="no">ERB</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="vi">@erb</span><span class="p">)</span><span class="o">.</span><span class="n">result</span><span class="p">(</span><span class="nb">binding</span><span class="p">)</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="k">module</span> <span class="nn">RenderProfiler</span>
</span><span class='line'>  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">included</span> <span class="n">base</span>
</span><span class='line'>    <span class="n">base</span><span class="o">.</span><span class="n">send</span> <span class="ss">:alias_method</span><span class="p">,</span> <span class="ss">:render_without_profiling</span><span class="p">,</span> <span class="ss">:render</span>
</span><span class='line'>    <span class="n">base</span><span class="o">.</span><span class="n">send</span> <span class="ss">:alias_method</span><span class="p">,</span> <span class="ss">:render</span><span class="p">,</span> <span class="ss">:render_with_profiling</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">render_with_profiling</span> <span class="n">values</span>
</span><span class='line'>    <span class="n">start</span> <span class="o">=</span> <span class="no">Time</span><span class="o">.</span><span class="n">now</span>
</span><span class='line'>    <span class="n">render_without_profiling</span><span class="p">(</span><span class="n">values</span><span class="p">)</span><span class="o">.</span><span class="n">tap</span> <span class="p">{</span>
</span><span class='line'>      <span class="vg">$stderr</span><span class="o">.</span><span class="n">puts</span> <span class="s2">&quot;Rendered in </span><span class="si">#{</span><span class="no">Time</span><span class="o">.</span><span class="n">now</span> <span class="o">-</span> <span class="n">start</span><span class="si">}</span><span class="s2">s.&quot;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Template</span>
</span><span class='line'>  <span class="kp">include</span> <span class="no">RenderProfiler</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="no">Template</span><span class="o">.</span><span class="n">ancestors</span>
</span><span class='line'>  <span class="c1">#=&gt; [Template, RenderProfiler, Object, Kernel, BasicObject]</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>使用 Ruby 2.0 的写法将变得非常简洁。</p>


<p><figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">RenderProfiler</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">render</span> <span class="n">values</span>
</span><span class='line'>    <span class="n">start</span> <span class="o">=</span> <span class="no">Time</span><span class="o">.</span><span class="n">now</span>
</span><span class='line'>    <span class="k">super</span><span class="p">(</span><span class="n">values</span><span class="p">)</span><span class="o">.</span><span class="n">tap</span> <span class="p">{</span>
</span><span class='line'>      <span class="vg">$stderr</span><span class="o">.</span><span class="n">puts</span> <span class="s2">&quot;Rendered in </span><span class="si">#{</span><span class="no">Time</span><span class="o">.</span><span class="n">now</span> <span class="o">-</span> <span class="n">start</span><span class="si">}</span><span class="s2">s.&quot;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Template</span>
</span><span class='line'>  <span class="n">prepend</span> <span class="no">RenderProfiler</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="no">Template</span><span class="o">.</span><span class="n">ancestors</span>
</span><span class='line'>  <span class="c1">#=&gt; [RenderProfiler, Template, Object, Kernel, BasicObject]</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>注意 include 和 prepend 的区别在于，执行后 ancestors 有明显不同，include 置于后方，而 prepend 置于前方，这就导致了方法查找路径的差异，从而导致 <code>super</code> 执行结果的差异。</p>




<h2>4. Lazy Enumerable</h2>




<p>Lazy Enumerable 可以让 Enumerable 不立即执行，这对函数式编程大有用处，例子如下：</p>


<p><figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">natural_numbers</span>
</span><span class='line'>  <span class="p">(</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="no">Float</span><span class="o">::</span><span class="no">INFINITY</span><span class="p">)</span><span class="o">.</span><span class="n">lazy</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">primes</span>
</span><span class='line'>  <span class="n">natural_numbers</span><span class="o">.</span><span class="n">select</span> <span class="p">{</span><span class="o">|</span><span class="n">n</span><span class="o">|</span>
</span><span class='line'>    <span class="p">(</span><span class="mi">2</span><span class="o">.</span><span class="n">.</span><span class="p">(</span><span class="n">n</span><span class="o">**</span><span class="mi">0</span><span class="o">.</span><span class="mi">5</span><span class="p">))</span><span class="o">.</span><span class="n">all?</span> <span class="p">{</span><span class="o">|</span><span class="n">f</span><span class="o">|</span>
</span><span class='line'>      <span class="n">n</span> <span class="o">%</span> <span class="n">f</span> <span class="o">&gt;</span> <span class="mi">0</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="n">primes</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">to_a</span>
</span><span class='line'>  <span class="c1">#=&gt; [1, 2, 3, 5, 7, 11, 13, 17, 19, 23]</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>除了上面 4 大特性，还有一些小的改变，比如:</p>




<ul>
<li>默认使用 <code>utf-8 encoding</code> 解析代码</li>
<li>Symbol 数组 <code>%i(a b c)</code> &#8211;> <code>[:a, :b, :c]</code></li>
<li>新的 GC</li>
<li>Ruby的性能也有所提升</li>
<li>&#8230;</li>
</ul>




<p>Ruby 2.0 让 Ruby 变得愈发性感了，我喜欢。</p>




<p>参考资料</p>




<ul>
<li><a href="http://blog.marc-andre.ca/2013/02/23/ruby-2-by-example/">http://blog.marc-andre.ca/2013/02/23/ruby-2-by-example/</a></li>
<li><a href="http://www.infoq.com/cn/news/2012/11/ruby-20-preview1">http://www.infoq.com/cn/news/2012/11/ruby-20-preview1</a></li>
<li><a href="http://benhoskin.gs/2013/02/24/ruby-2-0-by-example">http://benhoskin.gs/2013/02/24/ruby-2-0-by-example</a></li>
</ul>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[升级 Ruby 1.8.7 到 1.9.3]]></title>
    <link href="http://xiewenwei.github.com//blog/2013/01/03/update-ruby-1-8-to-1-9/"/>
    <updated>2013-01-03T22:52:00+08:00</updated>
    <id>http://xiewenwei.github.com//blog/2013/01/03/update-ruby-1-8-to-1-9</id>
    <content type="html"><![CDATA[<p>这几天对一个大型的 Rails 项目做 Ruby 升级，把升级过程中遇到的几个主要问题和解决方法记录下来以备参考。</p>

<h2>1. 带中文字符的源代码需要加上 utf-8 encoding 声明</h2>

<p>在 Ruby 1.9 中，如果源代码中包含中文字符，必须声明源代码文件的字符集，具体做法是在文件头部增加一个注释行：
<code># encoding: utf-8</code>。</p>

<p>做法很简单，但是当文件量很大时，一个一个手工修改文件也很麻烦，好在有一个 gem &#8211; magic_encoding 可以轻易解决这个烦恼。用法相当简单，通过 <code>gem install magic_encoding</code> 安装 gem，然后在 Rails 项目目录下执行 <code>magic_encoding</code> 命令，它自动把 Rails 项目所有源代码文件头部加上 <code># -*- encoding : utf-8 -*-</code>，非常简单方便。</p>

<p>参考：<a href="https://github.com/m-ryan/magic_encoding">magic_encoding in github</a></p>

<h2>2. 改变 <code>case var when value :</code> 用法</h2>

<p>在 Ruby 1.9 中，象下面这种 case when 语法已经不支持</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'>  <span class="k">case</span> <span class="n">var</span>
</span><span class='line'>    <span class="k">when</span> <span class="mi">1</span><span class="p">:</span>
</span><span class='line'>      <span class="s2">&quot;value of 1&quot;</span>
</span><span class='line'>    <span class="k">when</span> <span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">:</span>
</span><span class='line'>      <span class="s2">&quot;value of 2 and 3&quot;</span>
</span><span class='line'>    <span class="k">else</span>
</span><span class='line'>      <span class="s2">&quot;others&quot;</span>
</span><span class='line'>  <span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>修改很简单，把 <code>when value</code> 后的冒号去掉就行了。</p>

<h2>3. 字符串字符集问题</h2>

<p>在 Ruby 1.9 中，字符串对象带有字符集属性，不同字符集的字符串之间拼接会报异常，通常我们都是用 utf-8 encoding 的字符串，但有些类库返回的字符串返回的字符串并非 utf-8 encoding，这时候可能导致问题，需要做一些额外处理。</p>

<p>例如，Base64 解码后的字符串并不是 utf-8 的，拼接会报异常，需要做一次 force_encoding，看下面的代码。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">require</span> <span class="s1">&#39;base64&#39;</span>
</span><span class='line'><span class="n">s1</span> <span class="o">=</span> <span class="s2">&quot;薄荷网&quot;</span>
</span><span class='line'><span class="nb">puts</span> <span class="n">s1</span><span class="o">.</span><span class="n">encoding</span><span class="o">.</span><span class="n">to_s</span>
</span><span class='line'><span class="n">s2</span> <span class="o">=</span> <span class="no">Base64</span><span class="o">.</span><span class="n">encode64</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span>
</span><span class='line'><span class="n">s3</span> <span class="o">=</span> <span class="no">Base64</span><span class="o">.</span><span class="n">decode64</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span>
</span><span class='line'><span class="nb">puts</span> <span class="n">s3</span><span class="o">.</span><span class="n">encoding</span><span class="o">.</span><span class="n">to_s</span>
</span><span class='line'><span class="n">s4</span> <span class="o">=</span> <span class="n">s3</span><span class="o">.</span><span class="n">force_encoding</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>
</span><span class='line'><span class="nb">puts</span> <span class="n">s4</span><span class="o">.</span><span class="n">encoding</span><span class="o">.</span><span class="n">to_s</span>
</span><span class='line'><span class="nb">puts</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="n">s3</span><span class="si">}</span><span class="s2">很棒&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>结果是</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">UTF</span><span class="o">-</span><span class="mi">8</span>
</span><span class='line'><span class="no">ASCII</span><span class="o">-</span><span class="mi">8</span><span class="no">BIT</span>
</span><span class='line'><span class="no">UTF</span><span class="o">-</span><span class="mi">8</span>
</span><span class='line'><span class="no">Encoding</span><span class="o">::</span><span class="no">CompatibilityError</span><span class="p">:</span> <span class="n">incompatible</span> <span class="n">character</span> <span class="n">encodings</span><span class="p">:</span> <span class="no">ASCII</span><span class="o">-</span><span class="mi">8</span><span class="no">BIT</span> <span class="ow">and</span> <span class="no">UTF</span><span class="o">-</span><span class="mi">8</span>
</span><span class='line'>  <span class="n">blabla</span> <span class="o">.</span><span class="n">.</span><span class="o">.</span>
</span></code></pre></td></tr></table></div></figure>


<p>所以在 Base64 处理字符串的地方要相当小心。</p>

<h2>4. YAML 引擎改变引起的问题</h2>

<p>Ruby 1.9.3 中，YAML 引擎 由 Syck 改成了 Psych，Psych 和 Syck 在处理 UTF-8 字符串时有明显的区别，详见 <a href="http://galeki.is-programmer.com/posts/32636">Psych、Syck、YAML 和编码</a></p>

<p>总结：把 Ruby 从 1.8 升级到 1.9 还是比较轻松的，遇到的问题比想象中少，而且解决起来都不算麻烦。Ruby 兼容性方法做得很棒，赞一个。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[重构 NICE 方案程序]]></title>
    <link href="http://xiewenwei.github.com//blog/2012/12/16/refactor-nice-program/"/>
    <updated>2012-12-16T22:42:00+08:00</updated>
    <id>http://xiewenwei.github.com//blog/2012/12/16/refactor-nice-program</id>
    <content type="html"><![CDATA[<p>最近的工作需要对原有的 NICE 方案生成程序做重构，应用了流水线作业设计模式，让整个 NICE 方案生成代码变得结构清晰，而且易于扩展。</p>

<p>NICE 方案生成程序比较复杂，整体上分成两大步骤：一，根据用户的输入生成评测报告，二，根据用户输入和评测报告构建方案。以前的代码是非常典型的过程式的代码，简单的说就是把生成工作分解成多个步骤，为每一个步骤定义一个方法，然后在一个主控方法中分别调用各个方法。这看起来是比较简单的，但是升级维护变得很困难，比如要增加一个新版本的方案生成方法，不得不在代码中很多地方加入 <code>if else</code> 判断。</p>

<p>这次的工作就是要增加一个新版本的 NICE 方案生成方法，而且要求对之前的所有方案生成提供兼容。考虑再三，不打算在之前的代码上增加许多 <code>if else</code> 完成工作，于是对整个生成代码做一次大的重构。</p>

<p>从工厂流水线的工作方式得到启发，感觉 NICE 的评测和方案生成就象是流水线作业。NICE 评测从输入到评测报告的过程，可以抽象为 input 经过一系列的 analyzer 的处理，最后得到一个 evaluation result的过程。而 NICE 方案可以抽象为，输入是 input 和评测报告，经过一系列 builder 的处理，最后得多一个 solution result.</p>

<p>重构后，NICE 评测生成过程的核心类图如下：
<img src="http://xiewenwei.github.com//images/house/analyzer.png" alt="Analyzer" /></p>

<p>重构后，NICE 评测的主控过程代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'>  <span class="n">result</span> <span class="o">=</span> <span class="no">EvaluationResult</span><span class="o">.</span><span class="n">new</span>
</span><span class='line'>  <span class="c1"># Order of analyzer must be restricted</span>
</span><span class='line'>  <span class="o">[</span>
</span><span class='line'>    <span class="no">Evaluation</span><span class="o">::</span><span class="no">BodyAnalyzer</span><span class="p">,</span>
</span><span class='line'>    <span class="no">Evaluation</span><span class="o">::</span><span class="no">TagAnalyzer</span><span class="p">,</span>
</span><span class='line'>    <span class="no">Evaluation</span><span class="o">::</span><span class="no">TipAnalyzer</span>
</span><span class='line'>  <span class="o">].</span><span class="n">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">analyzer</span><span class="o">|</span> <span class="n">analyzer</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span><span class="o">.</span><span class="n">analyze</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1"># save result ...</span>
</span></code></pre></td></tr></table></div></figure>


<p>评测分析过程基类是 Analyzer，BodyAnalyzer，TagAnalyzer 和 TipAnalyzer 都从它继承而来，每一个 Analyzer 完成一部分的评测分析工作。重构之后，扩展评测变得很容易，只要增加一种特定的 Analyzer 即可，而且这个 Analyzer 完全可以从之前的 Analyzer 继承已达到代码复用。</p>

<p>重构后，NICE 方案生成过程的核心类图如下：
<img src="http://xiewenwei.github.com//images/house/builder.png" alt="Analyzer" /></p>

<p>重构后，NICE 评测的主控过程代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'>  <span class="n">result</span> <span class="o">=</span> <span class="no">SolutionResult</span><span class="o">.</span><span class="n">new</span>
</span><span class='line'>  <span class="n">input_wrapper</span> <span class="o">=</span> <span class="no">Solution</span><span class="o">::</span><span class="no">InputWrapper</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">input</span><span class="p">)</span>
</span><span class='line'>  <span class="c1"># Order of builder must be restricted</span>
</span><span class='line'>  <span class="o">[</span>
</span><span class='line'>    <span class="no">Solution</span><span class="o">::</span><span class="no">PreparingBuilder</span><span class="p">,</span>
</span><span class='line'>    <span class="no">Solution</span><span class="o">::</span><span class="no">WeekPlanBuilder</span><span class="p">,</span>
</span><span class='line'>    <span class="no">Solution</span><span class="o">::</span><span class="no">EatTipBuilder</span><span class="p">,</span>
</span><span class='line'>    <span class="no">Solution</span><span class="o">::</span><span class="no">ActivityPlanBuilder</span><span class="p">,</span>
</span><span class='line'>    <span class="no">Solution</span><span class="o">::</span><span class="no">ActTipBuilder</span><span class="p">,</span>
</span><span class='line'>    <span class="no">Solution</span><span class="o">::</span><span class="no">NoticeBuilder</span>
</span><span class='line'>  <span class="o">].</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">builder</span><span class="o">|</span>
</span><span class='line'>    <span class="n">builder</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">input_wrapper</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span><span class="o">.</span><span class="n">build</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1"># save result ...</span>
</span></code></pre></td></tr></table></div></figure>


<p>方案生成过程基类是 Builder，PreparingBuilder，WeekPlanBuilder 和 NoticeBuilder 都从它继承而来，每一个 Builder 完成一部分的方案生成工作。</p>

<p>流水线作业的设计模式很适合象 NICE 方案生成的工作，它的特点是：整体过程复杂，可以分解为多个类似的步骤，这些步骤共享相同的输入和输出对象。使用这种设计模式后，代码结果变成简单清晰，而且易于扩展维护。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby 常量查找路径]]></title>
    <link href="http://xiewenwei.github.com//blog/2012/12/09/ruby-constant-lookup/"/>
    <updated>2012-12-09T21:44:00+08:00</updated>
    <id>http://xiewenwei.github.com//blog/2012/12/09/ruby-constant-lookup</id>
    <content type="html"><![CDATA[<p>Ruby 的常量查找路径问题是一直困扰我的一个问题，在工作中遇到过好几次，一直没有彻底弄清楚到底为什么，最近在读一本书《Ruby 元编程》，对 Ruby 对象模型有了更深入的认识，另外读了一篇 blog《Everything you ever wanted to know about constant lookup in Ruby》, 让我总算把 Ruby 常量查找路径这个问题搞得比较清楚。</p>

<h2>第一个遇到的问题，我还曾经在 Ruby-China 上发过帖。</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">M1</span>
</span><span class='line'>  <span class="no">CT</span> <span class="o">=</span> <span class="s2">&quot;ok&quot;</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">C1</span>
</span><span class='line'>  <span class="no">CK</span> <span class="o">=</span> <span class="s2">&quot;ck&quot;</span>
</span><span class='line'>  <span class="kp">include</span> <span class="no">M1</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">method1</span>
</span><span class='line'>    <span class="nb">puts</span> <span class="nb">self</span>
</span><span class='line'>    <span class="nb">puts</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="no">CK</span><span class="si">}</span><span class="s2"> in method1&quot;</span>
</span><span class='line'>    <span class="nb">puts</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="no">CT</span><span class="si">}</span><span class="s2"> in method1&quot;</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">class</span> <span class="o">&lt;&lt;</span> <span class="nb">self</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">method2</span>
</span><span class='line'>      <span class="nb">puts</span> <span class="nb">self</span>
</span><span class='line'>      <span class="nb">puts</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="no">CK</span><span class="si">}</span><span class="s2"> in method1&quot;</span>
</span><span class='line'>      <span class="nb">puts</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="no">CT</span><span class="si">}</span><span class="s2"> in method2&quot;</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="no">C1</span><span class="o">.</span><span class="n">method1</span>
</span><span class='line'><span class="no">C1</span><span class="o">.</span><span class="n">method2</span>
</span></code></pre></td></tr></table></div></figure>


<p>输出结果是</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">C1</span>
</span><span class='line'><span class="n">ck</span> <span class="k">in</span> <span class="n">method1</span>
</span><span class='line'><span class="n">ok</span> <span class="k">in</span> <span class="n">method1</span>
</span><span class='line'><span class="no">C1</span>
</span><span class='line'><span class="n">ck</span> <span class="k">in</span> <span class="n">method2</span>
</span><span class='line'><span class="no">NameError</span><span class="p">:</span> <span class="n">uninitialized</span> <span class="n">constant</span> <span class="no">Class</span><span class="o">::</span><span class="no">CT</span>
</span><span class='line'>    <span class="n">from</span> <span class="p">(</span><span class="n">irb</span><span class="p">):</span><span class="mi">16</span><span class="ss">:in</span> <span class="sb">`method2&#39;</span>
</span></code></pre></td></tr></table></div></figure>


<p>这是我在重构薄荷网代码时候遇到的问题，method1 和 method2 都是常见的类方法的定义方面，我向来认为它们是等价可替换的写法，但是从实际执行的结果看，它们里面的常量查找路径不一样。</p>

<p>如果我把 M1 的定义改成下面的样子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">M1</span>
</span><span class='line'>  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">included</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
</span><span class='line'>    <span class="n">base</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>  <span class="no">CT</span> <span class="o">=</span> <span class="s2">&quot;ok&quot;</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>执行结果是：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">C1</span>
</span><span class='line'><span class="n">ck</span> <span class="k">in</span> <span class="n">method1</span>
</span><span class='line'><span class="n">ok</span> <span class="k">in</span> <span class="n">method1</span>
</span><span class='line'><span class="no">C1</span>
</span><span class='line'><span class="n">ck</span> <span class="k">in</span> <span class="n">method2</span>
</span><span class='line'><span class="n">ok</span> <span class="k">in</span> <span class="n">method2</span>
</span></code></pre></td></tr></table></div></figure>


<h2>还有一个问题是也是经常遇到的，抽象成问题代码如下：</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">A</span>
</span><span class='line'>  <span class="k">module</span> <span class="nn">M</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">a_method</span>
</span><span class='line'>      <span class="c1">#...</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">A</span><span class="o">::</span><span class="n">B</span>
</span><span class='line'>  <span class="kp">include</span> <span class="n">M</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>会报异常：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">NameError</span><span class="p">:</span> <span class="n">uninitialized</span> <span class="n">constant</span> <span class="n">A</span><span class="o">::</span><span class="n">B</span><span class="o">::</span><span class="n">M</span>
</span><span class='line'>  <span class="n">from</span> <span class="p">(</span><span class="n">irb</span><span class="p">):</span><span class="mi">10</span><span class="ss">:in</span> <span class="sb">`&lt;class:B&gt;&#39;</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Ruby 常量查找时依据两条路径</h2>

<ul>
<li>A. Module.nesting</li>
<li>B. open class/module 的 ancestors</li>
</ul>


<p>A 比 B 优先，A 找不到了才到 B 中查找。</p>

<p><code>A.Module.nesting</code> 的概念比较容易理解，它是指代码位置的 module 嵌套情况，它是一个数组，从最内层的嵌套一直到最外层的嵌套，如果没有嵌套，数组为空。任何一处代码位置都有 <code>Module.nesting</code> 值，可以通过下面的代码打印出各个位置的 Module.nesting 值。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">p</span> <span class="no">Module</span><span class="o">.</span><span class="n">nesting</span>
</span><span class='line'>
</span><span class='line'><span class="k">module</span> <span class="nn">A</span>
</span><span class='line'>  <span class="k">module</span> <span class="nn">B</span>
</span><span class='line'>    <span class="nb">p</span> <span class="no">Module</span><span class="o">.</span><span class="n">nesting</span>
</span><span class='line'>    <span class="k">module</span> <span class="nn">C</span>
</span><span class='line'>      <span class="nb">p</span> <span class="no">Module</span><span class="o">.</span><span class="n">nesting</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="k">module</span> <span class="nn">A::B</span>
</span><span class='line'>  <span class="nb">p</span> <span class="no">Module</span><span class="o">.</span><span class="n">nesting</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>输出是：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="o">[]</span>
</span><span class='line'><span class="o">[</span><span class="n">A</span><span class="o">::</span><span class="n">B</span><span class="p">,</span> <span class="n">A</span><span class="o">]</span>
</span><span class='line'><span class="o">[</span><span class="n">A</span><span class="o">::</span><span class="n">B</span><span class="o">::</span><span class="n">C</span><span class="p">,</span> <span class="n">A</span><span class="o">::</span><span class="n">B</span><span class="p">,</span> <span class="n">A</span><span class="o">]</span>
</span><span class='line'><span class="o">[</span><span class="n">A</span><span class="o">::</span><span class="n">B</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>大家有没有注意到，<code>module A::B</code> 这种快捷写法会导致 <code>A</code> 不在 <code>Module.nesting</code> 里，这就是上述第二个问题的根源，因为 M 是 A module 下的常量，<code>module A::B</code> 写法导致不会查找 <code>A::M</code>。</p>

<p>说完 <code>A Module.nesting</code>，再说一下 <code>B open class/module 的 ancestors</code>，这个问题相对复杂很多。简单的说，在 Ruby 代码的任何位置，都有一个 <code>self</code> 存在，同样也有一个 <code>open class/module</code> 存在，在模块和类定义处，它通常就是对应的模块和类，在方法内部，它是方法对应的类。对于 ancestors，我们可以通过代码位置 <code>open class/module</code> 的 ancestors 方法取得。</p>

<p>（备注：ancestors 在引入 singleton_class 概念之后变得有点复杂，如不清楚可参考《Ruby 元编程》）</p>

<p>上述第一个问题：
在method1 中
A 是 <code>[C1]</code>
<code>open class/module</code> 是 <code>C1</code>，所以 ancestors 是 <code>[C1, M1, Object, Kernel, BasicObject]</code>
CK 在 A 可以找到，CT 在 B 可以找到。</p>

<p>method2 中
A 是 <code>[C1]</code>
<code>open class/module</code> 是 <strong>C1 的 singleton_class</strong> , 所以 ancestors 是 <code>[Class, Module, Object, Kernel, BasicObject]</code>
CK 在 A 可以找到，CT 在 A 和 B 都找不到。</p>

<p>对于</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">M1</span>
</span><span class='line'>  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">included</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
</span><span class='line'>    <span class="n">base</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>  <span class="no">CT</span> <span class="o">=</span> <span class="s2">&quot;ok&quot;</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>可运行，是因为这时，在 method2 中，<code>open class/module</code> <strong>C1 的 singleton_class</strong> 扩展了 M1，所以 ancestors 变成了
<code>[M1, Class, Module, Object, Kernel, BasicObject]</code>。</p>

<p>至此，这两个困扰我多时的问题终于彻底搞清楚了。这个过程给我的一个体会是：面对技术上的一些疑问，如果只是浅尝辄止，是永远不能够真正掌握它的，只有深入专研，透彻理解它的原理，才能够真正掌握它，获得真正的能力提升。</p>

<p>文章提到的 blog 网址：
<a href="http://http://cirw.in/blog/constant-lookup">Everything you ever wanted to know about constant lookup in Ruby</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TestUnit的替代者MiniTest]]></title>
    <link href="http://xiewenwei.github.com//blog/2012/12/02/test-unitde-ti-dai-zhe-minitest/"/>
    <updated>2012-12-02T22:07:00+08:00</updated>
    <id>http://xiewenwei.github.com//blog/2012/12/02/test-unitde-ti-dai-zhe-minitest</id>
    <content type="html"><![CDATA[<p>MiniTest 是新一代的 Ruby 测试框架，它已经成为 Ruby 1.9 的内置测试框架，据说它也将成为Rails 4的默认测试框架，可谓前途一片光明。</p>

<h2>MiniTest 为什么成为最新 Ruby 和 Rails 的首选，它有哪些吸引人的东西呢？</h2>

<p>Ruby 1.8时代，Ruby 和 Rails 的默认测试框架都是 TestUnit，TestUnit 历史悠久，它最大的问题是太慢，太臃肿了，它包含了一堆现在很少使用的第三方库，比如GTk v1, GTk v2, FxRuby，另外一个大问题的是它缺乏一些基本的测试特性，比如 spec DSL的测试风格，比如 mock 支持等等。</p>

<p>MiniTest 相当于对 TestUnit 做了一次大的重构翻新，它继承了 TestUnit 大部分用法，消除 TestUnit 中不恰当的依赖，另外增加了基本的测试特性，比如 spec 和 mock等，整体上变得相当快速，简单整洁。</p>

<p>在 Ruby 和 Rails 的世界，有一个测试框架 Rspec 使用也是非常广泛的，甚至目前使用广泛程度超过 TestUnit 和 MiniTest，它为什么没有成为默认框架呢？我想 MiniTest 相对于 Rspec 最大的优势是简单和延续性，Rspec 相比 MiniTest 要庞大复杂得多，当然功能也更强大，对于内置 Ruby 的类库来说，还是简单和保持延续（相对 TestUnit）更有优势。对于 Rails 来说，Rails 之父 DHH 和 Rspec 一直对不上眼，我想是 Rails 最终选择 MiniTest 最大的原因，哈哈。</p>

<h2>MiniTest 使用示例</h2>

<p>如果你用过 TestUnit，MiniTest 使用非常简单，下面是一个测试的 Hello World</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">HelloWold</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">get_word</span>
</span><span class='line'>    <span class="s2">&quot;Hello World!&quot;</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>测试代码</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">require</span> <span class="s1">&#39;minitest/autorun&#39;</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">HelloWoldTest</span> <span class="o">&lt;</span> <span class="no">MiniTest</span><span class="o">::</span><span class="no">Unit</span><span class="o">::</span><span class="no">TestCase</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">test_get_word</span>
</span><span class='line'>    <span class="n">assert_equal</span> <span class="s2">&quot;Hello World!&quot;</span><span class="p">,</span> <span class="no">HelloWold</span><span class="o">.</span><span class="n">new</span><span class="o">.</span><span class="n">get_word</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>测试代码, spec风格</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">require</span> <span class="s1">&#39;minitest/autorun&#39;</span>
</span><span class='line'>
</span><span class='line'><span class="n">describe</span> <span class="no">HelloWold</span> <span class="k">do</span>
</span><span class='line'>  <span class="n">it</span> <span class="s2">&quot;should return hello world&quot;</span> <span class="k">do</span>
</span><span class='line'>    <span class="no">HelloWold</span><span class="o">.</span><span class="n">new</span><span class="o">.</span><span class="n">get_word</span><span class="o">.</span><span class="n">must_equal</span> <span class="s2">&quot;Hello World!&quot;</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>如果要在 Rails 项目使用 MiniTest，可以使用 gem minitest-rails</strong>，使用 <code>minitest-rails</code> 之后，rails generator 生成的 test 就都转换为 minitest 风格代码。</p>

<h2>总结</h2>

<p>MiniTest 相当简单快速，它延续 TestUnit用法，上手非常快，同时它又提供了一些非常棒的特性，试用下来觉得非常不错，难怪它成为最新 Ruby 和 Rails 的首选，我打算今后就用它了。</p>

<h2>参考资料</h2>

<ol>
<li><a href="https://github.com/seattlerb/minitest">minitest home</a></li>
<li><a href="https://github.com/blowmage/minitest-rails">minitest-rails home</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby的运算符和语句优先级]]></title>
    <link href="http://xiewenwei.github.com//blog/2012/11/25/rubyde-yun-suan-fu-he-yu-ju-you-xian-ji/"/>
    <updated>2012-11-25T22:03:00+08:00</updated>
    <id>http://xiewenwei.github.com//blog/2012/11/25/rubyde-yun-suan-fu-he-yu-ju-you-xian-ji</id>
    <content type="html"><![CDATA[<p>Ruby 是一种表达能力很强的语言，这得意于它异常丰富的运算符和语法糖，虽然 Ruby 一直把最小惊讶原则作为它的哲学之一，但还是常常看到让人惊讶不已，难于理解的代码，这可能是因为对它运算符和语句优先级理解不透导致，今天就和大家聊一聊 Ruby 运算符和语句的优先级。</p>

<p>先看一句简单的代码，猜一猜它的输出是什么。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'>  <span class="nb">puts</span> <span class="p">{}</span><span class="o">.</span><span class="n">class</span>
</span></code></pre></td></tr></table></div></figure>


<p>很多人一定以为结果是 Hash，但实事上结果是空，不信可以在 irb 里试一试。</p>

<p>再看一段代码。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">puts</span> <span class="s2">&quot;5 &amp;&amp; 3 is </span><span class="si">#{</span><span class="mi">5</span> <span class="o">&amp;&amp;</span> <span class="mi">3</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class='line'><span class="nb">puts</span> <span class="s2">&quot;5 and 3 is </span><span class="si">#{</span><span class="mi">5</span> <span class="ow">and</span> <span class="mi">3</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class='line'><span class="n">a</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">&amp;&amp;</span> <span class="mi">3</span>
</span><span class='line'><span class="n">b</span> <span class="o">=</span> <span class="mi">5</span> <span class="ow">and</span> <span class="mi">3</span>
</span><span class='line'><span class="nb">puts</span> <span class="s2">&quot;a is </span><span class="si">#{</span><span class="n">a</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class='line'><span class="nb">puts</span> <span class="s2">&quot;b is </span><span class="si">#{</span><span class="n">b</span><span class="si">}</span><span class="s2">&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>结果是：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="mi">5</span> <span class="o">&amp;&amp;</span> <span class="mi">3</span> <span class="n">is</span> <span class="mi">3</span>
</span><span class='line'><span class="mi">5</span> <span class="ow">and</span> <span class="mi">3</span> <span class="n">is</span> <span class="mi">3</span>
</span><span class='line'><span class="n">a</span> <span class="n">is</span> <span class="mi">3</span>
</span><span class='line'><span class="n">b</span> <span class="n">is</span> <span class="mi">5</span>
</span></code></pre></td></tr></table></div></figure>


<p>有没有觉得奇怪 b 怎么是 5 而不是 3 呢。</p>

<p>如果这两个例子你也觉得奇怪，那说明你对 Ruby 一些运算符和语句的优先级理解还不透彻，判断有误。
<code>puts {}.class</code> 实际上相当于 <code>(puts {}).class</code> -> <code>nil.class</code> 所以输出为空。<code>{}</code>相当于一个空的 block，优先和方法 puts 结合。
<code>&amp;&amp; 和 and</code> 的优先是不同的，而且和 <code>=</code> 号的优先级顺序比较， <code>&amp;&amp; &gt; = &gt; and</code>，所以 <code>a = 5 &amp;&amp; 3</code> 相当于 <code>a = ( 5 &amp;&amp; 3)</code>，而 <code>b = 5 and 3</code> 相当于 <code>( b = 5 ) and 3</code>，所以结果 a 和 b的值是不同的。</p>

<p>下面一张表格是 Ruby 中常见的运算符和语句的优先级列表，从上到下优先级递减。</p>

<table border="1" cellspacing="0">
<tr style="background:#efefef;">
  <caption>Ruby operators (highest to lowest precedence)</caption>
  <tr style="background:#efefef;">
    <th>Method</th>
    <th>Operator</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>Yes</td>
    <td><code>[ ]</code> <code>[ ]=</code></td>
    <td>Element reference, element set</td>
  </tr><tr>
    <td>Yes</td>
    <td><code>**</code></td>
    <td>Exponentiation (raise to the power)</td>
  </tr><tr>
    <td>Yes</td>
    <td><code>!</code> <code>~</code> <code>+</code> <code>-</code></td>
    <td>Not, complement, unary plus and minus (method names for the last two are <code>+@</code> and <code>-@</code>)</td>
  </tr><tr>
    <td>Yes</td>
    <td><code>*</code> <code>/</code> <code>%</code></td>
    <td>Multiply, divide, and modulo</td>
  </tr><tr>
    <td>Yes</td>
    <td><code>+</code> <code>-</code></td>
    <td>Addition and subtraction</td>
  </tr><tr>

    <td>Yes</td>
    <td><code>&gt;&gt;</code> <code>&lt;&lt;</code></td>
    <td>Right and left bitwise shift</td>
  </tr><tr>
    <td>Yes</td>
    <td><code>&amp;</code></td>
    <td>Bitwise `AND&#8217;</td>
  </tr><tr>
    <td>Yes</td>
    <td><code>^</code> <code>|</code></td>
    <td>Bitwise exclusive `OR&#8217; and regular `OR&#8217;</td>
  </tr><tr>
    <td>Yes</td>
    <td><code>&lt;=</code> <code>&lt;</code> <code>&gt;</code> <code>&gt;=</code></td>
    <td>Comparison operators</td>
  </tr><tr>
    <td>Yes</td>
    <td><code>&lt;=&gt;</code> <code>==</code> <code>===</code> <code>!=</code> <code>=~</code> <code>!~</code></td>
    <td>Equality and pattern match operators (<code>!=</code> and <code>!~</code> may not be defined as methods)</td>
  </tr><tr>
    <td></td>
    <td><code>&amp;&amp;</code></td>
    <td>Logical `AND&#8217;</td>
  </tr><tr>
    <td></td>
    <td><code>||</code></td>
    <td>Logical `AND&#8217;</td>
  </tr><tr>
    <td></td>
    <td><code>..</code> <code>...</code></td>
    <td>Range (inclusive and exclusive)</td>
  </tr><tr>
    <td></td>
    <td><code>?&nbsp;:</code></td>
    <td>Ternary if-then-else</td>
  </tr><tr>
    <td></td>
    <td><code>=</code> <code>%=</code> <code></code>{ <code>/=</code> <code>-=</code> <code>+=</code> <code>|=</code> <code>&amp;=</code> <code>&gt;&gt;=</code> <code>&lt;&lt;=</code> <code>*=</code> <code>&amp;&amp;=</code> <code>||=</code> <code>**=</code></td>
    <td>Assignment</td>
  </tr><tr>
    <td></td>
    <td><code>defined?</code></td>
    <td>Check if specified symbol defined</td>
  </tr><tr>
    <td></td>
    <td><code>not</code></td>
    <td>Logical negation</td>
  </tr><tr>
    <td></td>
    <td><code>or</code> <code>and</code></td>
    <td>Logical composition</td>
  </tr><tr>
    <td></td>
    <td><code>if</code> <code>unless</code> <code>while</code> <code>until</code></td>
    <td>Expression modifiers</td>
  </tr><tr>

    <td></td>
    <td><code>begin/end</code></td>
    <td>Block expression</td>
  </tr>
</table>


<br/>


<p>几条便于记忆的原则：</p>

<ol>
<li>关键字类如if and 等的优先级是要比符号类低；</li>
<li>赋值符号 <code>= ||=</code> 等优先级也比较低，仅次于关键字类；</li>
<li><code>[] []=</code> 元素引用的优先级非常高。</li>
</ol>

]]></content>
  </entry>
  
</feed>
