<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ruby | 程序人生]]></title>
  <link href="http://xiewenwei.github.com//blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://xiewenwei.github.com//"/>
  <updated>2015-01-11T23:16:34+08:00</updated>
  <id>http://xiewenwei.github.com//</id>
  <author>
    <name><![CDATA[vincent]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Rails 中 mattr_accessor 一处文档错误]]></title>
    <link href="http://xiewenwei.github.com//blog/2015/01/11/mattr-accessor-in-ruby-on-rails-activesupport/"/>
    <updated>2015-01-11T21:49:00+08:00</updated>
    <id>http://xiewenwei.github.com//blog/2015/01/11/mattr-accessor-in-ruby-on-rails-activesupport</id>
    <content type="html"><![CDATA[<h2>发现错误</h2>

<p>最近写一个 gem 的时候偶然接触到 Rails ActiveSupport 扩展 module 的 mattr_accessor 系列方法，包括 mattr_accessor、mattr_reader 和 mattr_writer。
记得以前探索 Rails 源代码的时候经常遇到 mattr_accessor 方法，当时并没有细究，这次碰巧要自己用到，所以仔细研究了其文档和实现源码，居然发现文档描述有明显的错误。</p>

<p>Rails 的官方文档中提到，mattr_accessor 用于为类属性定义类和实例对象两者的访问器，然后还提供一段示例代码演示其用法。</p>

<p><code>ruby
mattr_accessor(*syms, &amp;blk) public
Defines both class and instance accessors for class attributes.
</code>
演示代码如下：
```ruby</p>

<pre><code>module HairColors
  mattr_accessor :hair_colors
end

class Person
  include HairColors
end

Person.hair_colors = [:brown, :black, :blonde, :red]
Person.hair_colors     # =&gt; [:brown, :black, :blonde, :red]
Person.new.hair_colors # =&gt; [:brown, :black, :blonde, :red]
</code></pre>

<p>```</p>

<p>当我运行该代码的时候，发现无法运行，报错在 <code>Person.hair_colors</code> 处，信息如下：</p>

<p><code>ruby
[5] pry(main)&gt; Person.hair_colors = [:brown, :black, :blonde, :red]
NoMethodError: undefined method `hair_colors=' for Person:Class
from (pry):7:in `__pry__'
</code></p>

<p>刚开始还有点不相信，分别在 Rails 4.1.8，4.2.0 和 3.2.x，Ruby 1.9.3，2.0.0 和 2.1.5 下运行， 都出现这个错误，这下确信文档描述应该是有问题的。我想把问题彻底搞清楚，于是仔细查看 Rails ActiveSupport 中相关的源代码，发现的确是文档描述的行为和程序实际行为不符。</p>

<h2>探寻原因</h2>

<p>mattr_accessor 系列方法的代码在 <code>rails/activesupport/lib/active_support/core_ext/module/attribute_accessors.rb</code> 文件中，相关的代码并不复杂，部分代码如下：</p>

<p>```ruby
  # 此处忽略注释
  def mattr_writer(*syms)</p>

<pre><code>options = syms.extract_options!
syms.each do |sym|
  raise NameError.new("invalid attribute name: #{sym}") unless sym =~ /^[_A-Za-z]\w*$/
  class_eval(&lt;&lt;-EOS, __FILE__, __LINE__ + 1)
    @@#{sym} = nil unless defined? @@#{sym}

    def self.#{sym}=(obj)
      @@#{sym} = obj
    end
  EOS

  unless options[:instance_writer] == false || options[:instance_accessor] == false
    class_eval(&lt;&lt;-EOS, __FILE__, __LINE__ + 1)
      def #{sym}=(obj)
        @@#{sym} = obj
      end
    EOS
  end
  send("#{sym}=", yield) if block_given?
end
</code></pre>

<p>  end</p>

<p>  # 此处忽略注释
  def mattr_accessor(*syms, &amp;blk)</p>

<pre><code>mattr_reader(*syms, &amp;blk)
mattr_writer(*syms, &amp;blk)
</code></pre>

<p>  end</p>

<p>```</p>

<p>从中可以看到，mattr_accessor 分别 call mattr_reader 和 mattr_writer，mattr_writer 的主要逻辑是定义类变量（class variable，命名为 <code>@@#{sym}</code>），然后定义类方法 （见 <code>def self.#{sym}=(obj)</code>）和普通实例方法（见 <code>def #{sym}=(obj)</code>）。当 <code>Person include HairColors</code> 的时候，普通实例方法是 mix 进 Person 的，但类方法并不会被 mix 进 Person。可以用下面更简明的例子演示 include module 并不能 mix 类方法。</p>

<p>```ruby
  module Foo</p>

<pre><code>def method1
  puts "method1 in Foo"
end

def self.method2
  puts "method2 in Foo as class method"
end
</code></pre>

<p>  end</p>

<p>  class Bar</p>

<pre><code>include Foo
</code></pre>

<p>  end</p>

<p>  Bar.new.method1  # => "method1 in Foo"</p>

<p>  Foo.method2 # => "method2 in Foo as class method"</p>

<p>  Bar.method2 # => NoMethodError: undefined method `method2' for #&lt;Bar:0x007fdb0a121488>
```</p>

<p>原来 mattr_accessor 为 HairColors 生成的 <code>def self.hair_colors</code> 类方法不能 mix 进 Person，从而导致 Person.hair_colors 出错，但是 Person.new.hair_colors 能够正常运行的。</p>

<h2>解决方法</h2>

<p>如果希望 Person 通过类方法和实例方法都能使用 hair_colors ，应该怎么做呢？
可以把 mattr_accessor 放在 included 钩子中执行，代码如下所示：</p>

<p>```ruby</p>

<pre><code>module HairColors
  extend ActiveSupport::Concern
  included do
    mattr_accessor :hair_colors
  end
end

class Person
  include HairColors
end

Person.hair_colors = [:brown, :black, :blonde, :red]
Person.hair_colors     # =&gt; [:brown, :black, :blonde, :red]
Person.new.hair_colors # =&gt; [:brown, :black, :blonde, :red]
HairColors.hair_colors # =&gt; undefined method `hair_colors' for HairColors:Module
</code></pre>

<p>```</p>

<p>它的一个问题是 <code>HairColors.hair_colors</code> 不可用了，但我发现 Rails 中大多是使用这种手法处理的，这种情况下估计不怎么要直接用到 <code>HairColors.hair_colors</code> 吧。</p>

<h2>总结</h2>

<p>Rails 官方文档中关于 mattr_accessor 的描述的确有问题，示例代码不能正确运行，而且还会误导使用者，通过仔细探索 Rails 的源代码，找到了问题的源头。我已经修正文档的错误，提交了 <code>pull request</code>，希望能够被接受。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails 中 MySQL 分区表使用的一个注意事项]]></title>
    <link href="http://xiewenwei.github.com//blog/2014/12/14/mysql-partition-table-in-rails/"/>
    <updated>2014-12-14T22:46:00+08:00</updated>
    <id>http://xiewenwei.github.com//blog/2014/12/14/mysql-partition-table-in-rails</id>
    <content type="html"><![CDATA[<p>MySQL 的分区表是一种简单有效的处理极大数据表的特性，通过它可以使应用程序几乎很少改动就能达成对极大数据表的高效处理，但由于 Rails ActiveRecord 设计上一些惯例，可能导致一些数据处理不能利用分区表特性，反而变得很慢，在使用分区表过程中一定要多加注意。</p>

<p>下面以一个例子来说明。在 light 系统中，有一张数据表是 diet_items, 主要字段是 id, schedule_id, meal_order food_id, weight, calory 等等，它的每一条记录表示为用户生成每日的减肥计划（减肥食谱 + 运动计划）中的一条饮食项，平均一条的计划有 10 多条数据，数据量非常大，预计每天生成数据会超过 100 万条，所以对其做了分表处理，根据 schedule_id hash 分成 60 张表，也就是数据将动态分到 60 张表中。分表后 diet_items 的建表语句如下所示：</p>

<p><code>sql
CREATE TABLE `diet_items` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `schedule_id` int(11) NOT NULL,
  `meals_order` int(11) NOT NULL,
  `food_id` int(11) DEFAULT NULL,
  ....
  KEY id (`id`),
  UNIQUE KEY `index_diet_items_on_schedule_id_and_id` (`schedule_id`,`id`)
)
PARTITION BY HASH (schedule_id)
PARTITIONS 60;
</code>
分表之后，所有查询 diet_items 的地方都要求带上 schedule_id，比如获取某一个 schedule 的所有 diet_items，通过 schedule. diet_items，获取某一个 id 的 diet_item 也是通过  <code>schedule.diet_items.find(id)</code> 进行。生成 diet_item 也没有问题，因为生成 diet_item 都是通过 <code>schedule.diet_items.build(data)</code> 方式，在生成的时候都是带了 schedule_id 的。</p>

<p>观察 newrelic 日志，发现 diet_item 的 update 和 destroy 相关的请求特别慢，仔细分析后，发现这两种操作非常忙是由于 ActiveRecord 生成的 sql 并没有带 schedule_id 导致。
diet_item update 操作 ActiveRecord 生成的 sql 语句类似于 <code>update diet_items set … where id = &lt;id&gt;</code>。
diet_item destroy 生成的语句类似于 <code>delete diet_items where id = &lt;id&gt;</code>
因为没有带 schedule_id，导致这两种语句都需要 mysql 扫描 60 张分区表才能够完成一个语句执行，非常慢！</p>

<p>知道原因之后就好办了，把原来的 update 和 destroy 调用改为自定义版本的 update 和 destroy 调用就可以了。</p>

<ul>
<li><p><code>diet_item.update(attributes)</code> 改成 <code>DietItem.where(id: diet_item.id, schedule_id: diet_item.schedule_id).update_all(attributes)</code></p></li>
<li><p><code>diet_item.destroy</code> 改成 <code>DietItem.where(id: diet_item.id, schedule_id: diet_item.schedule_id).delete_all</code></p></li>
</ul>


<p>这样生成的 sql 都带上 schedule_id 条件，从而避免了扫描全部的分区表，性能提升立竿见影。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ActiveSupport::Concern 的工作原理]]></title>
    <link href="http://xiewenwei.github.com//blog/2014/01/13/how-activesupport-corncern-work/"/>
    <updated>2014-01-13T00:29:00+08:00</updated>
    <id>http://xiewenwei.github.com//blog/2014/01/13/how-activesupport-corncern-work</id>
    <content type="html"><![CDATA[<p>去年有一次的周记分享过 ActiveSupport::Concern （以下简称 Concern） 的用法，但是对它的实现原理一直不太明白，周末把它的实现源码仔细研究了一番，总算比较深入了解了它的工作原理，同时也让我对 Ruby 元编程有了更深的了解。</p>

<p>Concern 主要用于解决 module mix 的依赖问题，同时简化 module mix 的步骤。
关于依赖问题，必须用一个例子才好说明：</p>

<p>```ruby
module Foo
  def self.included(base)</p>

<pre><code>base.class_eval do
  def self.method_injected_by_foo
    ...
  end
end
</code></pre>

<p>  end
end</p>

<p>module Bar
  include Foo
  def self.included(base)</p>

<pre><code>base.method_injected_by_foo
</code></pre>

<p>  end
end</p>

<p>class Host
  include Foo # We need to include this dependency for Bar
  include Bar # Bar is the module that Host really needs
end
```</p>

<p>上面例子中 Host 为了 include Bar，必须得先 include Bar 依赖的 Foo，这是因为 Bar 在 include Foo 时，只是为 Bar extend method_injected_by_foo 方法，所以 Host 必须显式的 include Foo，才能够 extend method_injected_by_foo 方法。</p>

<p>使用 Concern 后，代码可以简写为</p>

<p>```ruby
require 'active_support/concern'</p>

<p>module Foo
  extend ActiveSupport::Concern
  included do</p>

<pre><code>class_eval do
  def self.method_injected_by_foo
    ...
  end
end
</code></pre>

<p>  end
end</p>

<p>module Bar
  extend ActiveSupport::Concern
  include Foo</p>

<p>  included do</p>

<pre><code>self.method_injected_by_foo
</code></pre>

<p>  end
end</p>

<p>class Host
  include Bar # works, Bar takes care now of its dependencies
end
```</p>

<p>Bar 和 Foo 都 <code>extend ActiveSupport::Concern</code> 后，Host include Bar 已经不需要事先 mix Foo。</p>

<p>这是怎么做到的呢，看看 Concern 的代码，其实代码很少：</p>

<p>```ruby
module
  module Concern</p>

<pre><code>def self.extended(base)
  base.instance_variable_set("@_dependencies", [])
end

def append_features(base)
  if base.instance_variable_defined?("@_dependencies")
    base.instance_variable_get("@_dependencies") &lt;&lt; self
    return false
  else
    return false if base &lt; self
    @_dependencies.each { |dep| base.send(:include, dep) }
    super
    base.extend const_get("ClassMethods") if const_defined?("ClassMethods")
    if const_defined?("InstanceMethods")
      base.send :include, const_get("InstanceMethods")
      ActiveSupport::Deprecation.warn "The InstanceMethods module inside ActiveSupport::Concern will be " \
        "no longer included automatically. Please define instance methods directly in #{self} instead.", caller
    end
    base.class_eval(&amp;@_included_block) if instance_variable_defined?("@_included_block")
  end
end

def included(base = nil, &amp;block)
  if base.nil?
    @_included_block = block
  else
    super
  end
end
</code></pre>

<p>  end
end
```</p>

<p>关键部分是 <code>append_features</code> 方法，通过阅读 ruby 的文档和源码得知，ruby 在 include 一个 module 时，实际会触发两个方法，一个是 append_features，进行实际的 mixing 操作，包括增加常量，方法和变量到模块中，另外一个是 included 方法，也就是我们常用来作为 include 钩子的方法，默认的 included 是一个空方法，我们通过重载它使钩子起作用。</p>

<p>从代码可知，当一个模块 <code>extend ActiveSupport::Concern</code> 时，将产生 3 个影响：</p>

<ol>
<li>为模块设置了一个实例变量</li>
</ol>


<p>变量为 @_dependencies，其值为空数组，表示依赖的模块，将在 append_features 中用到；</p>

<ol>
<li>append_features 方法被重载；</li>
</ol>


<p>重载后行为有了很大变化，它的处理分两种情况：
一种是当它被一个有 @<em>dependencies 实例变量的模块被 include 时，直接把自身加到 @</em>dependencies 中，
比如当 Bar include Foo 时，将触发 Foo 的 append_features(base) 方法，此时 base 是 Bar，self 是 Foo，由于 Bar 已经 <code>extend ActiveSupport::Concern</code>，Bar 的 @<em>dependencies 有定义，所以直接把 Foo 加到 Bar 的 @</em>dependencies 中，然后直接返回，没有立即执行 mixing 操作。</p>

<p>当 Host include Bar 时，将触发 Bar 的 append_features(base) 方法，此时
base 是 Host，self 是 Bar，Host 没有 <code>extend ActiveSupport::Concern</code>，所以 Host 的 @<em>dependencies 无定义，将执行下面的分支，首先 include Foo（通过 Bar 的 @</em>dependencies 获得 ），然后 include Bar (通过 super)，然后是后续操作。</p>

<ol>
<li>included 方法被重载；</li>
</ol>


<p>included 的动作比较简单，如果以没有参数形式调用，将把 block 存放到 @<em>included_block 变量中，@</em>included_block 的 block 将在 append_features 方法中使用。</p>

<p>通过施加的这 3 个影响，ActiveSupport::Concern 完成了它的全部功能，非常简洁精练。</p>

<p>从中学到的东西，包括：</p>

<ol>
<li><p>module 中 append_features 和 included 方法时 include 的核心；</p></li>
<li><p>可以通过覆盖这些方法改变操作的行为；</p></li>
<li><p>可以定义模块实例变量存储属于该模块的一些数据；</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby on Rails 线程安全代码]]></title>
    <link href="http://xiewenwei.github.com//blog/2014/01/12/thread-safety-code-for-ruby-on-rails/"/>
    <updated>2014-01-12T22:52:00+08:00</updated>
    <id>http://xiewenwei.github.com//blog/2014/01/12/thread-safety-code-for-ruby-on-rails</id>
    <content type="html"><![CDATA[<p>Ruby on Rails 4.0 的 rc 版本已经 release 了，Rails 4 时代最大的变化当属默认开启多线程模式。Rails 4 的多线程将给大家带来什么好处呢？至少有两方面：</p>




<ol>
<li><p>更高的系统吞吐量
Web 站点多是 IO 密集型的，多线程可以让 Application 在等待 IO 操作的同时，还能接收处理请求，大大提升系统吞吐量，增强系统稳定性和安全性。</p></li>
<li><p>更省内存
Ruby on Rails 是内存消耗大户，一个 Applicaion 占用几百兆是常事，以前使用仅使用多进程的并发模式时，整体内存消耗巨大，使用多进程+多线程的并发模式，不单系统吞吐量大大提供，系统整体使用内存也大幅下降。</p></li>
</ol>




<p>但是天下没有免费的午餐，在享用这些好处的同时，我们也必须付出一定的代价，代价就是要应付多线程编程带来的复杂性。程序中需要处理多线程可能导致问题的地方，如果程序中出现问题也变得更加难以发现调试。</p>




<p>好在需要注意的地方也不是太多，下面把这几个需要注意的地方一一说明。</p>




<h2>代码加载</h2>




<p>Ruby 的 require 并非线程安全的，在多线程中 require，可能会导致严重的不可预期的错误。例如下面的一个演示程序在 Ruby 1.9 环境下执行会发生死锁。</p>




<p>a.rb 文件：</p>


<p><figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">puts</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="no">Thread</span><span class="o">.</span><span class="n">current</span><span class="si">}</span><span class="s2">: a.rb&quot;</span>
</span><span class='line'><span class="nb">sleep</span> <span class="mi">1</span>
</span><span class='line'><span class="nb">puts</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="no">Thread</span><span class="o">.</span><span class="n">current</span><span class="si">}</span><span class="s2">: requiring b&quot;</span>
</span><span class='line'><span class="nb">require</span> <span class="s1">&#39;b&#39;</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>b.rb 文件：</p>


<p><figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">puts</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="no">Thread</span><span class="o">.</span><span class="n">current</span><span class="si">}</span><span class="s2">: b.rb&quot;</span>
</span><span class='line'><span class="nb">puts</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="no">Thread</span><span class="o">.</span><span class="n">current</span><span class="si">}</span><span class="s2">: requiring a&quot;</span>
</span><span class='line'><span class="nb">require</span> <span class="s1">&#39;a&#39;</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>test.rb 文件：</p>


<p><figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="vg">$LOAD_PATH</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;.&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="n">t1</span> <span class="o">=</span> <span class="no">Thread</span><span class="o">.</span><span class="n">new</span> <span class="p">{</span> <span class="nb">require</span> <span class="s1">&#39;a&#39;</span> <span class="p">}</span>
</span><span class='line'><span class="n">t2</span> <span class="o">=</span> <span class="no">Thread</span><span class="o">.</span><span class="n">new</span> <span class="p">{</span> <span class="nb">require</span> <span class="s1">&#39;b&#39;</span> <span class="p">}</span>
</span><span class='line'><span class="n">t1</span><span class="o">.</span><span class="n">join</span>
</span><span class='line'><span class="n">t2</span><span class="o">.</span><span class="n">join</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>在 Ruby 1.9 环境下运行 test.rb 将报死锁错误：</p>


<p><figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c">#&lt;Thread:0x007fd2da90a268&gt;: b.rb</span>
</span><span class='line'><span class="c">#&lt;Thread:0x007fd2da90a268&gt;: requiring a</span>
</span><span class='line'><span class="c">#&lt;Thread:0x007fd2da90a2e0&gt;: a.rb</span>
</span><span class='line'><span class="c">#&lt;Thread:0x007fd2da90a2e0&gt;: requiring b</span>
</span><span class='line'>test.rb:5:in <span class="sb"><code>&lt;/span&gt;join&lt;span class="s1"&gt;&amp;#39;: deadlock detected (fatal)&lt;/span&gt;
&lt;/span&gt;&lt;span class='line'&gt;&lt;span class="s1"&gt;  from test.rb:5:in</code>&lt;main&gt;&#39;</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>因为 Ruby require 不是线程安全的，所以 Rails 中使用多线程环境时，需要对 require 做一定的限制，简单的说就是在 Application 启动的时候，把所有需要加载的代码全部加载完成，避免启动后还 require。Rails 4 的生产环境配置中该选项已经默认生效。需要注意的时，如果你的代码不在 Rails 默认的几个目录中，你需要手动配置你的目录进入 eager_load_path，例如：</p>


<p><figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">config</span><span class="o">.</span><span class="n">eager_load_paths</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="no">Rails</span><span class="o">.</span><span class="n">root</span><span class="si">}</span><span class="s2">/lib&quot;</span>
</span></code></pre></td></tr></table></div></figure></p>

<h2>全局变量和类变量写操作</h2>




<p>在 Rails 多线程环境，所有的全局变量（包括 $var @@var 和 类实例变量），在实例方法中都应该是只读的，尽量应该避免写操作。</p>




<p>下面是一个在实例方法中写类变量导致问题的例子：</p>


<p><figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">HomeController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>
</span><span class='line'>  <span class="n">before_filter</span> <span class="ss">:set_site</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="nf">index</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="kp">private</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="nf">set_site</span>
</span><span class='line'>    <span class="vi">@site</span> <span class="o">=</span> <span class="no">Site</span><span class="o">.</span><span class="n">find_by_subdomain</span><span class="p">(</span><span class="n">request</span><span class="o">.</span><span class="n">subdomains</span><span class="o">.</span><span class="n">first</span><span class="p">)</span>
</span><span class='line'>    <span class="k">if</span> <span class="vi">@site</span><span class="o">.</span><span class="n">layout?</span>
</span><span class='line'>      <span class="nb">self</span><span class="o">.</span><span class="n">class</span><span class="o">.</span><span class="n">layout</span><span class="p">(</span><span class="vi">@site</span><span class="o">.</span><span class="n">layout_name</span><span class="p">)</span>
</span><span class='line'>    <span class="k">else</span>
</span><span class='line'>      <span class="nb">self</span><span class="o">.</span><span class="n">class</span><span class="o">.</span><span class="n">layout</span><span class="p">(</span><span class="s1">&#39;default_lay&#39;</span><span class="p">)</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>上面代码的意图是根据域名设置不同的 layout。<code>self.class.layout(value)</code> 中，Rails 把 value 保存在类变量 <code>@@layout_</code>，然后在 render 的时候使用。</p>




<p>设想这样一种情况 UserA 的 subdomain 是 foo1，他的 layout 应该是 foo1，
UserB 的 subdomain 是 foo2，他的 layout 应该是 foo2。</p>




<p>UserA 和 UserB 同时请求应用，他们的请求分别在 Thread1 和 Thread2 中执行，执行顺序可能是：</p>




<ol>
<li>Thread1, 执行进入 set_site 方法，设置 <code>@@layout_</code> 为 foo1；</li>
<li>Thread2, 执行进入 set_site 方法，设置 <code>@@layout_</code> 为 foo2；</li>
<li>Thread1, render response，使用最新的 <code>@@layout_</code> foo2 render；</li>
<li>Thread2，render response，使用最新的 <code>@@layout_</code> foo2 render；</li>
</ol>




<p>我们期望 Thread1 使用 foo1 layout render，这样的执行结果和期望的不相符。</p>




<p>线程安全的写法是：</p>


<p><figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">HomeController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>
</span><span class='line'>  <span class="n">before_filter</span> <span class="ss">:set_site</span>
</span><span class='line'>  <span class="n">layout</span> <span class="ss">:site_layout</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="nf">index</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="kp">private</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="nf">set_site</span>
</span><span class='line'>    <span class="vi">@site</span> <span class="o">=</span> <span class="no">Site</span><span class="o">.</span><span class="n">find_by_subdomain</span><span class="p">(</span><span class="n">request</span><span class="o">.</span><span class="n">subdomains</span><span class="o">.</span><span class="n">first</span><span class="p">)</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="nf">site_layout</span>
</span><span class='line'>    <span class="k">if</span> <span class="vi">@site</span><span class="o">.</span><span class="n">layout?</span>
</span><span class='line'>      <span class="vi">@site</span><span class="o">.</span><span class="n">layout_name</span>
</span><span class='line'>    <span class="k">else</span>
</span><span class='line'>      <span class="s1">&#39;default_lay&#39;</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>程序在每次需要使用 layout 时，调用实例方法 <code>site_layout</code>，避免写类变量。</p>




<h2>IO Connection</h2>




<p>Rails 应用通常会用到多个 IO Connection，比如 ActiveRecord 的数据库 Connection，缓存 Memcached 的 Connection，Redis 的 Connection 等等。这些 IO Connection 在 Rails 多线程环境下并不都是线程安全的。</p>




<p>ActiveRecord 的 Connection 是线程安全的，而且 ActiveRecord 还可配置 Connection Pool，这样可以更高效率的利用数据库连接。</p>




<p>Memcached 的 Connection memchached-client 并不是线程安全的，最新的 dalli 是线程安全的。不过 dalli 的线程安全机制是在每个读写操作时加上互斥信号控制，这意味着同一时间只有一个线程可以操作，如果操作非常频繁的话，可能有性能上的问题，这个时候可以使用一个单独的 Connection Pool Gem 解决。</p>




<p>这个 Connection Pool Gem 的地址是 https://github.com/mperham/connection_pool。</p>




<p>Redis 的 Connection 和 dalli 类似，本身通过加上互斥信号控制保证线程安全，可以通过 Connection Pool 增强效率。</p>




<h2>使用互斥信号控制非线程安全操作</h2>




<p>在程序中，如果存在某些不希望多个线程同时执行的操作，可以使用互斥信号控制其执行，这样当已经有一个线程进入执行时，其他进入的 thread 都会被 block 住，等前面的进程执行结束后才会进入执行，从而保证在一个时间只有一个线程会执行。</p>




<p>示例代码如下：</p>


<p><figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">HomeController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>
</span><span class='line'>  <span class="vc">@@lock</span> <span class="o">=</span> <span class="no">Mutex</span><span class="o">.</span><span class="n">new</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="nf">index</span>
</span><span class='line'>    <span class="vc">@@lock</span><span class="o">.</span><span class="n">synchronize</span> <span class="k">do</span>
</span><span class='line'>      <span class="n">thread_unsafe_code</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="kp">private</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="nf">thread_unsafe_code</span>
</span><span class='line'>    <span class="k">if</span> <span class="vc">@@something</span> <span class="o">==</span> <span class="s1">&#39;hello&#39;</span>
</span><span class='line'>      <span class="n">do_hello</span>
</span><span class='line'>    <span class="k">elsif</span> <span class="vc">@@something</span> <span class="o">==</span> <span class="s1">&#39;world&#39;</span>
</span><span class='line'>      <span class="n">do_world</span>
</span><span class='line'>    <span class="k">else</span>
</span><span class='line'>      <span class="vc">@@something</span> <span class="o">=</span> <span class="s1">&#39;nothing&#39;</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>总之，Rails 的多线程为我们提供了简便的提升系统伸缩性的能力，这也意味的程序复杂性的增加，有几处地方使我们需要注意的，只有这样才能很好的利用 Rails 多线程能力。</p>




<p>参考：</p>




<ul>
<li><a href="http://m.onkey.org/thread-safety-for-your-rails/">http://m.onkey.org/thread-safety-for-your-rails/</a></li>
<li><a href="http://blog.headius.com/2008/08/qa-what-thread-safe-rails-means.html/">http://blog.headius.com/2008/08/qa-what-thread-safe-rails-means.html/</a></li>
<li><a href="http://tenderlovemaking.com/2012/06/18/removing-config-threadsafe.html/">http://tenderlovemaking.com/2012/06/18/removing-config-threadsafe.html/</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[多 Ruby 版本和 多 Gem 版本测试]]></title>
    <link href="http://xiewenwei.github.com//blog/2014/01/05/multiple-rubies-and-gems-test-solution/"/>
    <updated>2014-01-05T22:58:00+08:00</updated>
    <id>http://xiewenwei.github.com//blog/2014/01/05/multiple-rubies-and-gems-test-solution</id>
    <content type="html"><![CDATA[<p>admin_gateway 是用于我们所有后台统一认证和授权的组件，而我们后台程序运行在多个 Ruby 版本上，主要是 Ruby 1.9.3 和 2.0，Ruby 2.1 也已经发布了，很快也需要提供 Ruby 2.1 的支持，另外 Rails 版本有 3.0，3.2 和 4.0 三大主要版本，因此一个完整的测试方案是需要包括这 3 * 3 = 9 种组合才行。</p>

<p>首先是多个 Ruby 版本测试。这个问题比较简单，我们现在的 Ruby 环境通常是由 RVM 管理的，RVM 可以很容易的以多个 Ruby 版本重复执行 Ruby 程序，比如下面的例子：
<code>rvm ruby-1.9.3,ruby-2.0.0,ruby-2.1.0 exec ruby -e "puts RUBY_VERSION"</code>
如果运行的机器安装了这3个版本的 Ruby 的话，就会依次执行打出各自的 Ruby 版本号。
所以下面的命令就可以依次运行3个Ruby版本的测试了：</p>

<p><code>rvm ruby-1.9.3,ruby-2.0.0,ruby-2.1.0 exec bundle install</code>
<code>rvm ruby-1.9.3,ruby-2.0.0,ruby-2.1.0 exec bundle exec rake test</code></p>

<p>解决多 Ruby 版本测试的问题，然后就是多 Rails 版本测试的问题。admin_gateway 这个 gem 是一个 Rails Engine，因此需要依赖 Rails。多 Rails 版本测试意味着 test 的 gem 环境是不同的，而现在 gem 环境是由 bundle 管理的，运行 bundle 命令时可以手动指定 Gemfile 文件，因此 建立多个 Gemfile 文件，重复上面的命令就可以了，例如可以建立 rails_4_0.gemfile 这个 Gemfile，然后通过命令
<code>bundle install --gemfile rails_4_0.gemfile</code>
执行 gem 环境安装，
然后通过命令：
<code>BUNDLE_GEMFILE=rails_4_0.gemfile bundle exec rake test</code>
执行测试。</p>

<p>组合上面的方法，可以形成一个完整的多 Ruby 版本和 Rails 版本的解决方案：
1. 首先根据需要安装多个 Ruby 版本，如 ruby 1.9.3, 2.0.0 和 2.1.0，根据需要生成多个 gemfile，如 rails_3_0.gemfile, rails_3_2.gemfile 和 rails_4_0.gemfile
2. 然后使用下面的 shell 安装 gem 环境和运行测试。
<code>rvm ruby-1.9.3,ruby-2.0.0,ruby-2.1.0 exec bundle install --gemfile=rails_3_0.gemfile</code>
<code>BUNDLE_GEMFILE=rails_3_0.gemfile rvm ruby-1.9.3,ruby-2.0.0,ruby-2.1.0 exec bundle exec rake test</code>
3.2 和 4.0的类似，就不重复了。</p>

<p>解决 gem 多版本的方法有一点不干净，因为 gemfile 有很多重复内容，shell命令也比较重复，因此有一个 gem 叫 appraise （https://github.com/cfedermann/Appraise）就是用于解决这个问题，它只需要配置一个 Appraisals 文件，在 Appraisals 声明不同的 gem 依赖就可以了，比如 admin_gateway 的 Appraisals 内容如下：
```
appraise "rails-3-0" do
  gem "rails", "3.0.20"
end</p>

<p>appraise "rails-3-2" do
  gem "rails", "3.2.16"
end</p>

<p>appraise "rails-4-0" do
  gem "rails", "4.0.0"
end
```
然后就可以通过 rake appraisal 完成多个 rails 版本测试，它的原理和上面提到的完全一样。</p>

<p>总之，多 Ruby 版本和多 gem 版本的测试并不难，利用 rvm 和 bundle 一些特性可以快速做到，利用 appraisal 可以让其更简化。</p>
]]></content>
  </entry>
  
</feed>
