
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>程序人生</title>
  <meta name="author" content="vincent">

  
  <meta name="description" content="唯一计数 (也叫基数计数）是网站系统中十分常见的一个功能特性，例如网站需要统计每天访问的人数 unique visitor （也就是 UV）。计数问题很常见，但因为情况的不同，解决起来可能十分复杂：一是需要计数的量可能很大，比如大型的站点每天有数百万的人访问，数据量相当大； &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://xiewenwei.github.com//">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/stylesheets/data-table.css" media="screen, projection" rel="stylesheet" type="text/css" />
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="程序人生" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<!--
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
-->

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">程序人生</a></h1>
  
    <h2>写优雅的程序，做优雅的人</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://www.google.com.hk/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:xiewenwei.github.com/" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about-me/">About Me</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/12/28/cardinality-counting-using-redis/">使用 Redis 进行唯一计数（基数计数）的 3 种方法</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-12-28T23:06:00+08:00" pubdate data-updated="true">2014-12-28</time>
        
         | <a href="/blog/2014/12/28/cardinality-counting-using-redis/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>唯一计数 (也叫基数计数）是网站系统中十分常见的一个功能特性，例如网站需要统计每天访问的人数 unique visitor （也就是 UV）。计数问题很常见，但因为情况的不同，解决起来可能十分复杂：一是需要计数的量可能很大，比如大型的站点每天有数百万的人访问，数据量相当大；二是通常还希望扩展计数的维度，比如除了需要每天的 UV，还想知道每周或每月的 UV，这样导致计算十分复杂。</p>

<p>在关系数据库存储的系统里，实现唯一计数的方法就是 <code>select count(distinct &lt;item_id&gt;)</code>，它十分简单，但是如果数据量很大，这个语句执行是很慢的。用关系数据库另外一个问题是查询和插入数据的性能也不高。</p>

<p>Redis 解决这类计数问题得心应手，相比关系数据库速度更快，消耗的资源更少，甚至根据不同情况提供了 3 种不同的方法。</p>

<ol>
<li>基于 set
Redis 的 set 用于保存唯一的数据集合，通过它可以快速判断某一个元素是否存在于集合中，也可以快速计算某一个集合的元素个数，另外和可以合并集合到一个新的集合中。涉及的命令如下：</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>SISMEMBER key member  # 判断 member 是否存在
</span><span class='line'>SADD key member  # 往集合中加入 member
</span><span class='line'>SCARD key   # 获取集合元素个数 </span></code></pre></td></tr></table></div></figure>


<p>基于 set 的方法简单有效，计数精确，适用面广，易于理解，它的缺点是消耗资源比较大（当然比起关系数据库是少很多的），如果元素个数很大（比如上亿的计数），消耗内存很恐怖。</p>

<ol>
<li>基于 bit
Redis 的 bit 可以用于实现比 set 内存高度压缩的计数，它通过一个 bit 1 或 0 来存储某个元素是否存在信息。例如网站唯一访客计数，可以把 user_id 作为 bit 的偏移量 offset，设置为 1 表示有访问，使用 1 MB的空间就可以存放 800 多万用户的一天访问计数情况。涉及的命令如下：</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>SETBIT key offset value  # 设置位信息
</span><span class='line'>GETBIT key offset        # 获取位信息
</span><span class='line'>BITCOUNT key [start end] # 计数
</span><span class='line'>BITOP operation destkey key [key ...]  # 位图合并 </span></code></pre></td></tr></table></div></figure>


<p>基于 bit 的方法比起 set 空间消耗小得多，但是它要求元素能否简单映射为位偏移，适用面窄了不少，另外它消耗的空间取决于最大偏移量，和计数值无关，如果最大偏移量很大，消耗内存也相当可观。</p>

<ol>
<li>基于 HyperLogLog
实现超大数据量精确的唯一计数都是比较困难的，但是如果只是近似的话，计算科学里有很多高效的算法，其中 HyperLogLog Counting 就是其中非常著名的算法，它可以仅仅使用 12 k左右的内存，实现上亿的唯一计数，而且误差控制在百分之一左右。
涉及的命令如下：</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>PFADD key element [element ...]  # 加入元素
</span><span class='line'>PFCOUNT key [key ...]   # 计数</span></code></pre></td></tr></table></div></figure>


<p>这种计数方法真的很神奇，我也没有彻底弄明白，有兴趣可以深入研究相关文章。</p>

<p>redis 提供的这三种唯一计数方式各有优劣，可以充分满足不同情况下的计数要求。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/12/14/mysql-partition-table-in-rails/">Rails 中 MySQL 分区表使用的一个注意事项</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-12-14T22:46:00+08:00" pubdate data-updated="true">2014-12-14</time>
        
         | <a href="/blog/2014/12/14/mysql-partition-table-in-rails/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>MySQL 的分区表是一种简单有效的处理极大数据表的特性，通过它可以使应用程序几乎很少改动就能达成对极大数据表的高效处理，但由于 Rails ActiveRecord 设计上一些惯例，可能导致一些数据处理不能利用分区表特性，反而变得很慢，在使用分区表过程中一定要多加注意。</p>

<p>下面以一个例子来说明。在 light 系统中，有一张数据表是 diet_items, 主要字段是 id, schedule_id, meal_order food_id, weight, calory 等等，它的每一条记录表示为用户生成每日的减肥计划（减肥食谱 + 运动计划）中的一条饮食项，平均一条的计划有 10 多条数据，数据量非常大，预计每天生成数据会超过 100 万条，所以对其做了分表处理，根据 schedule_id hash 分成 60 张表，也就是数据将动态分到 60 张表中。分表后 diet_items 的建表语句如下所示：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='sql'><span class='line'><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="o">`</span><span class="n">diet_items</span><span class="o">`</span> <span class="p">(</span>
</span><span class='line'>  <span class="o">`</span><span class="n">id</span><span class="o">`</span> <span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="n">AUTO_INCREMENT</span><span class="p">,</span>
</span><span class='line'>  <span class="o">`</span><span class="n">schedule_id</span><span class="o">`</span> <span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
</span><span class='line'>  <span class="o">`</span><span class="n">meals_order</span><span class="o">`</span> <span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
</span><span class='line'>  <span class="o">`</span><span class="n">food_id</span><span class="o">`</span> <span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">DEFAULT</span> <span class="k">NULL</span><span class="p">,</span>
</span><span class='line'>  <span class="p">....</span>
</span><span class='line'>  <span class="k">KEY</span> <span class="n">id</span> <span class="p">(</span><span class="o">`</span><span class="n">id</span><span class="o">`</span><span class="p">),</span>
</span><span class='line'>  <span class="k">UNIQUE</span> <span class="k">KEY</span> <span class="o">`</span><span class="n">index_diet_items_on_schedule_id_and_id</span><span class="o">`</span> <span class="p">(</span><span class="o">`</span><span class="n">schedule_id</span><span class="o">`</span><span class="p">,</span><span class="o">`</span><span class="n">id</span><span class="o">`</span><span class="p">)</span>
</span><span class='line'><span class="p">)</span>
</span><span class='line'><span class="n">PARTITION</span> <span class="k">BY</span> <span class="n">HASH</span> <span class="p">(</span><span class="n">schedule_id</span><span class="p">)</span>
</span><span class='line'><span class="n">PARTITIONS</span> <span class="mi">60</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>分表之后，所有查询 diet_items 的地方都要求带上 schedule_id，比如获取某一个 schedule 的所有 diet_items，通过 schedule. diet_items，获取某一个 id 的 diet_item 也是通过  <code>schedule.diet_items.find(id)</code> 进行。生成 diet_item 也没有问题，因为生成 diet_item 都是通过 <code>schedule.diet_items.build(data)</code> 方式，在生成的时候都是带了 schedule_id 的。</p>

<p>观察 newrelic 日志，发现 diet_item 的 update 和 destroy 相关的请求特别慢，仔细分析后，发现这两种操作非常忙是由于 ActiveRecord 生成的 sql 并没有带 schedule_id 导致。
diet_item update 操作 ActiveRecord 生成的 sql 语句类似于 <code>update diet_items set … where id = &lt;id&gt;</code>。
diet_item destroy 生成的语句类似于 <code>delete diet_items where id = &lt;id&gt;</code>
因为没有带 schedule_id，导致这两种语句都需要 mysql 扫描 60 张分区表才能够完成一个语句执行，非常慢！</p>

<p>知道原因之后就好办了，把原来的 update 和 destroy 调用改为自定义版本的 update 和 destroy 调用就可以了。</p>

<ul>
<li><p><code>diet_item.update(attributes)</code> 改成 <code>DietItem.where(id: diet_item.id, schedule_id: diet_item.schedule_id).update_all(attributes)</code></p></li>
<li><p><code>diet_item.destroy</code> 改成 <code>DietItem.where(id: diet_item.id, schedule_id: diet_item.schedule_id).delete_all</code></p></li>
</ul>


<p>这样生成的 sql 都带上 schedule_id 条件，从而避免了扫描全部的分区表，性能提升立竿见影。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/11/16/how-to-resolve-updating-conflict-in-rails/">如何解决 Rails 中同时修改冲突</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-11-16T22:51:00+08:00" pubdate data-updated="true">2014-11-16</time>
        
         | <a href="/blog/2014/11/16/how-to-resolve-updating-conflict-in-rails/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Rails 应用程序中操作冲突是一个常见问题，Rails 提供了简单有效的解决方法。</p>

<p>举一个实际的例子：我们的系统里有一个商店模块，商店中重要的一块是对产品信息的管理，比如运营人员常常会编辑产品的信息，包括产品标题，营销口号和价格等等。因为修改十分频繁，碰巧同时编辑提交修改的话，就会偶尔遇到修改丢失的问题，运营人员 A 修改产品标题，运营人员 B 修改价格，A 和 B 提交修改都提示修改成功，但是结果上只是 A 的修改结果生效，B 的修改被 A 的修改冲掉了。</p>

<p>仔细研究原因，发现是因为修改功能缺少操作冲突机制，而修改操作同时发生导致了问题。
如下图所示，A 和 B 同时从数据库中查询数据，在 web 页面中修改同样的数据，提交保存时是以 web 页面中提交的数据为准，从而导致 A 的修改把 B 的修改给覆盖了。</p>

<p><img src="/images/house/rails_conflict.png" alt="A和B修改冲突" /></p>

<p>Rails 的 乐观锁<a href="http://api.rubyonrails.org/classes/ActiveRecord/Locking/Optimistic.html">Optimistic Locking</a> 是解决这个问题的有力工具，它的原理是在数据库表中增加一个字段（默认是 lock_version，可配置）记录数据的版本号，每个提交的修改都带上这个版本号，在真正 update 修改数据之前，先判断提交的 lock_version 数据和数据库中的是否一致，如果不一致，则认为发生数据冲突，将抛出 <code>ActiveRecord::StaleObjectError</code> 异常，这样程序就可以捕获这个异常，提醒用户发生了冲突，由用户去协调解决冲突。</p>

<p>相关示例代码如下所示：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># migration: add lock_version to products</span>
</span><span class='line'><span class="n">add_column</span> <span class="ss">:products</span><span class="p">,</span> <span class="ss">:lock_version</span><span class="p">,</span> <span class="ss">:integer</span><span class="p">,</span> <span class="n">defalut</span><span class="p">:</span> <span class="mi">0</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># update product with StaleObjectError checking</span>
</span><span class='line'><span class="k">begin</span>
</span><span class='line'>  <span class="n">product</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">params</span><span class="o">[</span><span class="ss">:product</span><span class="o">]</span><span class="p">)</span>
</span><span class='line'><span class="k">rescue</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">StaleObjectError</span>
</span><span class='line'>  <span class="n">render</span> <span class="s1">&#39;confilct&#39;</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/10/26/a-http-sniffer-tool-pproxy/">http 抓包分析工具 pproxy</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-10-26T23:26:00+08:00" pubdate data-updated="true">2014-10-26</time>
        
         | <a href="/blog/2014/10/26/a-http-sniffer-tool-pproxy/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>引言</h2>

<p>  web 开发和 API 开发中难免要详细分析 http 请求和响应信息。web 开发的话，浏览器提供了便利的工具，比如 chrome 和 IE 都带了 develop tool，而 firefox 更是有十分强大的 firebug，可以让 http 请求的所有秘密一览无遗。目前是 app 大流行的时代，想要观察 app 中得 http 请求的秘密，浏览器的工具和插件都无能为力，有不少本地化的软件可以很好的解决这个问题，Windows 平台下有大名鼎鼎的 Fiddler 和 HttpWatch，Mac 平台下有 Charles。Charles 是一个收费软件，价格不菲要 $50。钱还不是关键问题，作为一名 geek，当然想更向往开源，轻量的解决方案了，无意中发现 pproxy，简单使用了一下，觉得相当棒，可以做绝佳的替代方案。</p>

<h2>比较</h2>

<p>  pproxy 和 Fiddler、Charles 最大的不同是，它是一个开源软件，使用 go 编写，代码托管在 github 上。因为开源，作为一名 geek，就可以通过阅读源代码对其工作机制一探究竟，如果发觉某些方面不能满足需求，可以直接向开发者提需求，也可以自己动手，丰衣足食，造福大众。</p>

<p>  pproxy 的工作机制和本地化软件如 Fiddler、Charles 差别很大。Fiddler 和 Charles 是一个本地化软件，通常是安装在桌面电脑上，通过在桌面电脑建立 proxy，然后截获的 http 请求和响应数据，提供一个本地化的 UI 界面提供服务。而 pproxy 是一个服务端软件，通常安装在 Linux 服务器上（当然也是可以安装在桌面电脑上），在服务器上建立 proxy 截获 http 请求和响应数据，另外提供一个远程的基于 web (html5)的 UI 界面提供服务。</p>

<p>  Fiddler UI 如下所示：</p>

<p>  <img src="/images/house/fiddler.gif" alt="Fiddler UI" /></p>

<p>  pproxy UI 如下所示：</p>

<p>  <img src="/images/house/pproxy.png" alt="pproxy UI" /></p>

<h2>使用</h2>

<p>  pproxy 使用比较简单，具体可以参考其使用说明 <a href="https://github.com/hidu/pproxy">pproxy</a>。
  难得的是他的作者是中国人，所以说明都是中文的。</p>

<h2>总结</h2>

<p>  pproxy 是一个开源的轻巧的 http 抓包分析工具，尤其适合 API http 请求分析，完全可以替换昂贵的收费工具，同时也可以探索其源码学习 GO 语言，学习 http 协议和分析方法。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/08/31/avoid-misusing-redis/">避免误用 Redis</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-08-31T23:29:00+08:00" pubdate data-updated="true">2014-08-31</time>
        
         | <a href="/blog/2014/08/31/avoid-misusing-redis/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Redis 是目前 NoSQL 领域的当红炸子鸡，它象一把瑞士军刀，小巧、锋利、实用，特别适合解决一些使用传统关系数据库难以解决的问题。但是 Redis 不是银弹，有很多适合它解决的问题，但是也有很多并不适合它解决的问题。另外，Redis 作为内存数据库，如果用在不适合的场合，对内存的消耗是很可观的，甚至会让系统难以承受。</p>

<p>我们可以对系统存储使用的数据以两种角度分类，一种是按数据的大小划分，分成大数据和小数据，另一种是按数据的冷热程度划分，分成冷数据和热数据，热数据是指读或写比较频繁的数据，反之则是冷数据。</p>

<p>可以举一些具体的例子来说明数据的大小和冷热属性。比如网站总的注册用户数，这明显是一个小而热的数据，小是因为这个数据只有一个值，热是因为注册用户数随时间变化很频繁。再比如，用户最新访问时间数据，这是一个量比较大，冷热不均的数据，大是数据的粒度是用户级别，每一个用户都有数据，如果有一千万用户，就意味着有一千万的数据，冷热不均是因为活跃用户的最新访问时间变化很频繁，但是可能有很大一部非活跃用户访问时间长时间不会发生变化。</p>

<p>大体而言，Redis 最适合处理的是小而热，而且是写频繁，或者读写都比较频繁的热数据。对于大而热的数据，如果其它方式很难解决问题，也可以考虑使用 Redis 解决，但是一定要非常谨慎，防止数据无限膨胀。原因如下：</p>

<p>首先，对于冷数据，无论大小，都不建议放在 Redis 中。Redis 数据要全部放在内存中，资源宝贵，把冷数据放在其中实在是一种浪费，冷数据放在普通的存储比如关系数据库中就好了。</p>

<p>其次，对于热数据，尤其是写频繁的热数据，如果量比较小，是最适合放到 Redis 中的。比如上面提到的网站总的注册用户数，就是典型的 Redis 用做计数器的例子。再比如论坛最新发表列表，最新报名列表，可以控制数量在几百到一千的规模，也是典型的 redis 做最新列表的使用方式。</p>

<p>另外，对于量比较大的热数据（或者冷热不均数据），使用 Redis 时一定要比较谨慎。这种类型数据很容易引起数据膨胀，导致 Redis 消耗内存巨大，让系统难以承受。薄荷的一个惨痛教训是把用户关注（以及被关注）数据放在 Redis 中，这是一种数据量极大，冷热很不均衡的数据，在几百万的用户级别就占用了近 10 GB左右内存，让 Redis 变得难以应付。应对这种类型的数据，可以用普通存储 + 缓存的方式。</p>

<p>如果用对了地方，比如在小而热的数据情形，Redis 表现很棒，如果用错了地方，Redis 也会带来昂贵的代价，所以使用时务必谨慎。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/08/10/dig-into-git-branch-and-tag/">实例探索 Git 的分支 branch 和标签 tag</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-08-10T23:38:00+08:00" pubdate data-updated="true">2014-08-10</time>
        
         | <a href="/blog/2014/08/10/dig-into-git-branch-and-tag/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>上一篇讲到 Git 的对象模型，通过它已经能够深入了解 Git 背后如何组织和储存数据，但是总觉得还是缺一点什么，那就是 Git 的必杀技分支和对象模型的关系，接下来就通过一些实例来弄清楚 Git 的分支是如何运作的。</p>

<p>在 Git 对象模型中讲到，每一次 Git 提交，都会生成一个 commit 对象，这个 commit 对象有一个 SHA1 key，例如 4240c635214402420f4fd907c378f0d01a5b5d8e。简单的说，Git 的分支就是一个引用 reference，这个引用有一个名称（分支的名称），然后指向一个具体的 commit 对象（通过 commit 对象的 key），就是这么简单。</p>

<p>分支的数据保存在那里呢？都在目录 <code>.git/refs</code> 中，通常这个目录下有三个子目录，分别是 heads，tags 和 remotes。
我们可以看到 <code>.git/refs/heads</code> 下有一些文件，每一个文件表示一个分支，文件的名称就是分支的名称，文件的内容就是 commit 对象的 key。</p>

<p>例如，dig-git 项目里：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cat .git/refs/heads/master
</span><span class='line'>058ca0a55e60eae77dac9818f915dad581b5465b
</span><span class='line'>cat .git/refs/heads/test1
</span><span class='line'>0c5ca6c9e46a1e6cfe04eaea7cd5db3223ba6693</span></code></pre></td></tr></table></div></figure>


<p>是不是很简单，知道了这个原理，我们甚至可以绕开 Git 命令，直接通过文件操作生成一个 branch。
例如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>echo "3c31e0a28cfc7f022984d6f8250a1c5c0670f120" &gt;&gt; .git/refs/heads/test2</span></code></pre></td></tr></table></div></figure>


<p>通过上面的命令，在 <code>.git/refs/heads</code> 目录下生成一个 test2 文件，文件内容是一个 commit 对象的 key，这样就生成了一个 test2 分支。</p>

<p>标签 tag 和分支 branch 的本质是一样的，都是一个指向 commit 对象的引用，只不过标签 tag 的文件放在 <code>.git/refs/tags</code> 目录下而已。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/08/03/dig-into-git-object-model/">实例探索 Git 对象模型</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-08-03T18:48:00+08:00" pubdate data-updated="true">2014-08-03</time>
        
         | <a href="/blog/2014/08/03/dig-into-git-object-model/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>一个纯研究演示 Git 对象模型的项目，项目在  https://github.com/xiewenwei/dig-git，总共有 5 次 commit（包括一次 merge），都是很简单的内容，我们可以仔细观察一下每一 commit 之后 Git 对象模型图，以此分析 Git 存储的原理。</p>

<ul>
<li><ol>
<li>首次提交，提交一个简单的文件 a.txt ，commit 之后的图如下：</li>
</ol>
</li>
</ul>


<p><img src="https://ruby-china-files.b0.upaiyun.com/photo/2014/9c44291362d64765803afba65fa2a0a4.png" alt="" /></p>

<p>如图所示，生成了 3 个对象，一个 commit 对象，一个 tree 对象，一个 blob 对象。图上蓝底是 commit 对象，灰底的是 tree 对象，白底的是 blob 对象，每个对象节点的标题是对象的 key (SHA 摘要)缩略表示。
对于 commit 对象，tree 内容表示这个 commit 对应根目录的 tree 对象，parent 表示父 commit 节点，通常commit 只有一个父节点，也可能没有（首次提交时 parent 为空），也可能有多个（合并节点），commit 对象还保存了 commit message 等信息。
对于 tree 对象，里面的内容包含了文件名，文件对应的 blob 对象的 key，或者是目录名和目录对应 tree 对象的 key。
对于 blob 对象，表示一个实际文件对象的内容，但不包括文件名，文件名是在 tree 对象里存的。</p>

<p>这个图怎么得到的呢？主要是两个命令：
* 通过 <code>git log</code> 命令获取最新 commit 的 key
* 通过 <code>git cat-file -p &lt;object key&gt;</code>  获取 key 对应 object 的内容，根据 object 里的内容，继续探索，就可以访问到所有关联 object.</p>

<ul>
<li><ol>
<li>第 2 次提交，修改了 a.txt 文件：</li>
</ol>
</li>
</ul>


<p><img src="https://ruby-china-files.b0.upaiyun.com/photo/2014/ba84d2ce8ba5066444a3e382ed644206.png" alt="" /></p>

<p>因为 a.txt 文件已经修改，生成了一个新的 blob 对象，tree 对象和 commit 对象。如图所示，commit 对象之间是有关联的，新提交的 commit 对象的 parent 是上一次提交的 commit 对象。</p>

<ul>
<li><ol>
<li>第 3 次提交，这次已稍微复杂一点，增加一个新文件 b.txt ，一个新目录 lib ，lib 里增加一个文件 c.txt</li>
</ol>
</li>
</ul>


<p><img src="https://ruby-china-files.b0.upaiyun.com/photo/2014/1ab7f0d2ab24734f0af6fc2d8e7c7a7d.png" alt="" /></p>

<p>如图所示，目录是有一个 tree 对象表示的，里面的内容指明了目录包含的文件或子目录。</p>

<ul>
<li><ol>
<li>第 4 次提交，这次弄出一个新的分支 test1，并且在新分支中做了一次 commit</li>
</ol>
</li>
</ul>


<p><img src="https://ruby-china-files.b0.upaiyun.com/photo/2014/8378188d524614d5b12bc27c42404a24.png" alt="" /></p>

<p>0c5ca 对应的 commit 对象就是生成的分支 test1 中的。分支在 Git 中是一个非常轻量化的操作，建立分支甚至都不增加新的对象。</p>

<ul>
<li><ol>
<li>第 5 次提交，这次涉及到一个合并操作，图已经变得比较复杂了</li>
</ol>
</li>
</ul>


<p><img src="https://ruby-china-files.b0.upaiyun.com/photo/2014/8e555b42a9775d725bd95ee7f369af7c.png" alt="" /></p>

<p>def18 就是合并后的 commit 对象。合并生成了一个新的commit ，这个 commit 的 parent 有两个，指向合并的两个原分支对应的 commit 上。</p>

<p>抱歉没有写得很详细，恐怕需要自己参照例子试试一看看，搞明白这些图，也就能搞明白整个 Git 对象模型机制了。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/07/13/capistrano-to-servers-behind-gateway/">使用 capistrano 部署到内部服务器</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-07-13T14:44:00+08:00" pubdate data-updated="true">2014-07-13</time>
        
         | <a href="/blog/2014/07/13/capistrano-to-servers-behind-gateway/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>capistrano 是使用方便，功能强大的自动化部署工具，它已经成为 Ruby 部署事实上的标准，薄荷项目自动化部署一直使用 capistrano。以前薄荷的服务器基本上是物理机，这些物理机都直接连接外网，最近租用了一些了云主机，为了更好的安全性，同时也为了节约成本，绝大大部分云主机并没有连接外网，只能通过一台连接外网的中转机连接。我们需要把应用部署到这些内部服务器上，最初我们使用了在中转机进行端口转发的方式，最近使用 capistrano deploy via gateway（姑且把它称为网关中转）方式，十分方便。</p>

<p>服务器部署示意图如下所示：</p>

<p><img src="/images/house/top.png" alt="服务器部署示意图" /></p>

<h2>端口转发方式</h2>

<p>端口转发方式要对中转服务器端口转发做设置，在 iptables 中配置例子如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-A PREROUTING -p tcp -m tcp --dport 10222 -j DNAT --to-destination 192.168.1.102:22</span></code></pre></td></tr></table></div></figure>


<p>端口转发实质上和 capistrano 没有直接关系，是在网络层面对中转服务器和内网实际部署服务器做了设置，让 capistrano 通过一个特定的端口与内网服务器通信，在 capistrano 看起来，内网服务器和中转服务器是一样的，只是端口不同而已。</p>

<h2>网关中转方式</h2>

<p>网关中转方式下，部署客户机首先和中转服务器建立连接，中间服务器再和内网服务器建立连接，部署工作站和内网服务器通过这两个连接通信。网关中转方式通过 capistrano 设置 deploy via gateway 选项完成，不需要对中转服务器做转发设置。</p>

<p>需要注意的是，使用网关中转方式时，capistrano 2.x 和 capistrano 3.x 差异很大，两种并不兼容。</p>

<p>capistrano 2.x 设置很简单，只要设置 gateway 选项就行了，如下所示：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'>  <span class="c1"># 实际使用中要把 &lt;user&gt; 和 &lt;gateway host&gt; 替换为真实值</span>
</span><span class='line'>  <span class="n">set</span> <span class="ss">:gateway</span><span class="p">,</span> <span class="s2">&quot;&lt;user&gt;@&lt;gateway host&gt;&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>capistrano 2.x 的设置在 capistrano 3.x 下不能工作，原因是 cap3 对网络连接做了非常大得重构，原来一些特性使用接口有变化。
capistrano 3.x 设置如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'>  <span class="nb">require</span> <span class="s1">&#39;net/ssh/proxy/command&#39;</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1"># 实际使用中要把 &lt;user&gt; 和 &lt;gateway host&gt; 替换为真实值</span>
</span><span class='line'>  <span class="n">set</span> <span class="ss">:ssh_options</span><span class="p">,</span> <span class="n">proxy</span><span class="p">:</span>
</span><span class='line'>    <span class="no">Net</span><span class="o">::</span><span class="no">SSH</span><span class="o">::</span><span class="no">Proxy</span><span class="o">::</span><span class="no">Command</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s1">&#39;ssh &lt;user&gt;@&lt;gateway host&gt; -W %h:%p&#39;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>总结：capistrano 可以通过简单的设置完成向内网服务器部署应用，有端口转发和网关中转两种方式，推荐使用网关中转方式。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/07/06/redis-use-pattern-1-counter/">Redis 使用模式之一：计数器</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-07-06T23:23:00+08:00" pubdate data-updated="true">2014-07-06</time>
        
         | <a href="/blog/2014/07/06/redis-use-pattern-1-counter/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Redis 是目前 NoSQL 领域的当红炸子鸡，它象一把瑞士军刀，小巧、锋利、实用，特别适合解决一些使用传统关系数据库难以解决的问题。打算写一系列 Redis 使用模式的文章，深入总结介绍 Redis 常见的使用模式，以供大家参考。</p>

<h2>常见汇总计数器</h2>

<p>汇总计数是系统常见功能，比如网站通常需要统计注册用户数，网站总浏览次数等等。
使用 Redis 提供的基本数据类型就能实现汇总计数器，通过 <code>incr</code> 命令实现增加操作。</p>

<p>比如注册用户数，基本操作命令如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  # 获取注册用户数
</span><span class='line'>  get total_users
</span><span class='line'>  # 注册用户数增加一位
</span><span class='line'>  incr total_users</span></code></pre></td></tr></table></div></figure>


<h2>按时间汇总的计数器</h2>

<p>通常计数还要按时间统计，比如注册用户数需要按日统计，处理方法比较简单，把日期带入计数器 key 就可以。</p>

<p>还是注册用户计数的例子，基本操作命令如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  # 假定操作 2014-07-06 数据
</span><span class='line'>  # 获取注册用户数
</span><span class='line'>  get total_users:2014-07-06
</span><span class='line'>  # 2014-07-06 注册用户数增加一位
</span><span class='line'>  incr total_users:2014-07-06
</span><span class='line'>  # 设置 48 小时过期时间 172800 = 48 * 60 * 60
</span><span class='line'>  expire total_users:2014-07-06 172800</span></code></pre></td></tr></table></div></figure>


<p>为计数器设置一个 48 小时的过期时间是为了节省计数器占用空间，毕竟 redis 是内存数据库，可以在过期前执行一个任务把计数器存入关系数据库。</p>

<h2>速度控制</h2>

<p>速度控制也是 Redis 一种常见的计数用途，比如有一个 API 服务，希望控制每一个 IP 每秒请求数不超过 10 次，可以用 IP 和 时间秒作为 key 设置一个计数器，实现控制，伪代码如下所示：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'>  <span class="c1"># 每秒最大请求数</span>
</span><span class='line'>  <span class="no">MAX_REQUESTS_PER_SECOND</span> <span class="o">=</span> <span class="mi">10</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1"># 检查 ip 请求限制</span>
</span><span class='line'>  <span class="c1"># @param ip</span>
</span><span class='line'>  <span class="c1"># @raise 超过限制，抛出 RuntimeError 异常</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="nf">check_request_limitation_for_ip</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span>
</span><span class='line'>    <span class="n">time_tick</span> <span class="o">=</span> <span class="no">Time</span><span class="o">.</span><span class="n">now</span><span class="o">.</span><span class="n">to_i</span>
</span><span class='line'>    <span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="n">ip</span><span class="si">}</span><span class="s2">:</span><span class="si">#{</span><span class="n">time_tick</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class='line'>    <span class="n">num</span> <span class="o">=</span> <span class="vg">$redis</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="o">.</span><span class="n">to_i</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">num</span> <span class="o">&gt;</span> <span class="no">MAX_REQUEST_PER_SECOND</span>
</span><span class='line'>      <span class="k">raise</span> <span class="s1">&#39;too many requests&#39;</span>
</span><span class='line'>    <span class="k">else</span>
</span><span class='line'>      <span class="vg">$redis</span><span class="o">.</span><span class="n">incr</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
</span><span class='line'>      <span class="vg">$redis</span><span class="o">.</span><span class="n">expire</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<h2>使用 Hash 数据类型维护大量计数器</h2>

<p>有时候需要维护大量计数器，比如每一个论坛主题的查看数，比如每一个用户访问页面次数，因为论坛主题和用户基数可能很大，直接基于论坛主题或用户 ID 生成计数器的话，占用 Redis 资源还是相当可观的，这时可以用 Hash 数据类型压缩所需资源。</p>

<p>比如，对应论坛主题查看计数，可以由模式</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'>  <span class="n">key</span><span class="p">:</span> <span class="n">topic</span><span class="p">:</span><span class="o">&lt;</span><span class="n">topic_id</span><span class="o">&gt;</span><span class="ss">:views</span>
</span><span class='line'>  <span class="n">value</span><span class="p">:</span> <span class="n">view</span> <span class="n">count</span> <span class="p">(</span><span class="n">integer</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>
转换为模式：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'>  <span class="n">key</span><span class="p">:</span> <span class="n">topic</span><span class="ss">:views</span>
</span><span class='line'>  <span class="n">value</span><span class="p">:</span> <span class="nb">hash</span>
</span><span class='line'>    <span class="nb">hash</span> <span class="n">key</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">topic_id</span><span class="o">&gt;</span>
</span><span class='line'>    <span class="nb">hash</span> <span class="n">value</span><span class="p">:</span> <span class="n">view</span> <span class="n">count</span> <span class="p">(</span><span class="n">integer</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>总结：利用 Redis 实现计数器，可以简单高效实现各种计数功能。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/29/build-index-in-mongodb/">MongoDB 中建索引注意事项</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-29T23:42:00+08:00" pubdate data-updated="true">2014-06-29</time>
        
         | <a href="/blog/2014/06/29/build-index-in-mongodb/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>上周在 ruby-china 上发了帖子《MongoDB 那些坑》，反映相当热烈，许多回复很有见地，其中一位童鞋深入的提到 MongoDB 建索引方法的问题，引发我更深入的了解了 MongoDB 建索引的方法和一些注意事项。</p>

<p>在 《MongoDB 那些坑》中提到，在前台直接运行建立索引命令的话，将造成整个数据库阻塞，因此索引建议使用 background 的方式建立。但是这也会带来一定的问题，在 2.6 版本之前，在 secondary server 中即使使用 background 方式建立索引，secondary 还是会以 foreground 方式建立索引，它导致 secondary 同样引发数据库阻塞问题。2.6 版本修复了这个 Bug，2.6 版之后使用 background 方式建立索引时，真正转向后台运行了。</p>

<p>为了尽量降低建立索引对 MongoDB Server 的影响，有一种方法是把 MongoDB Server 转换成 standalone 模式后建立。具体做法如下：</p>

<ol>
<li><p>首先把 secondary server 停止，在取消 <code>--replSet</code> 参数，并且更改 MongoDB port 之后重新启动 MongoDB，这时候 MongoDB 将进入 standalone 模式；</p></li>
<li><p>在 standalone 模式下运行命令 ensureIndex 建立索引，建议使用 foreground 方式运行；</p></li>
<li><p>建立索引完毕之后关闭 secondary server 按正常方式启动;</p></li>
<li><p>根据上述 1~3 的步骤轮流为 secondary 建立索引，最后把 primary server 临时转换为 secondary server，同样按 1~3 的方法建立索引，再把其转换为 primary server。</p></li>
</ol>


<p> 这种方式还是比较麻烦的，但可以把建立索引操作对 MongoDB 的影响降到最低，在有些情况下还是值得做的。</p>

<p> 参考资料：
 <a href="http://docs.mongodb.org/manual/tutorial/build-indexes-on-replica-sets/">build-indexes-on-replica-sets</a></p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/2/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/12/28/cardinality-counting-using-redis/">使用 Redis 进行唯一计数（基数计数）的 3 种方法</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/12/14/mysql-partition-table-in-rails/">Rails 中 MySQL 分区表使用的一个注意事项</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/11/16/how-to-resolve-updating-conflict-in-rails/">如何解决 Rails 中同时修改冲突</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/10/26/a-http-sniffer-tool-pproxy/">http 抓包分析工具 pproxy</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/08/31/avoid-misusing-redis/">避免误用 Redis</a>
      </li>
    
  </ul>
</section>






  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - vincent -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'bohe';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>











</body>
</html>
