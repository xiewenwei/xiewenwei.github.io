
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>程序人生</title>
  <meta name="author" content="vincent">

  
  <meta name="description" content="在开发和使用微服务间通信组件 SneakersPacker 过程中遇到异常处理的一些问题，通过解决这些问题让我对 ruby 中捕获异常和定义异常有新的认识。 当初遇到的问题是这样的：薄荷的一个子系统 status 中原本使用 http api call 获取 record 子系统的一些数据，应用 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://xiewenwei.github.com//">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/stylesheets/data-table.css" media="screen, projection" rel="stylesheet" type="text/css" />
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="程序人生" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<!--
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
-->

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">程序人生</a></h1>
  
    <h2>写优雅的程序，做优雅的人</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://www.google.com.hk/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:xiewenwei.github.com/" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about-me/">About Me</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/02/21/how-to-rescue-exception-in-ruby/">怎样才是 ruby 中捕获异常的正确姿势？</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2016-02-21T22:06:00+08:00" pubdate data-updated="true">2016-02-21</time>
        
         | <a href="/blog/2016/02/21/how-to-rescue-exception-in-ruby/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>在开发和使用微服务间通信组件 <a href="https://github.com/xiewenwei/sneakers_packer">SneakersPacker</a> 过程中遇到异常处理的一些问题，通过解决这些问题让我对 ruby 中捕获异常和定义异常有新的认识。</p>

<p>当初遇到的问题是这样的：薄荷的一个子系统 status 中原本使用 http api call 获取 record 子系统的一些数据，应用 <code>SneakersPacker</code> 之后，把代码改成了 rpc call。刚开始的时候 SneakersPacker 还有一些问题，为了防止 rpc call 出状况，在代码中提供了一层保护机制，也就是当 <code>SneakersPacker.remote_call</code> 触发异常之后，通过 http api call 获取数据。代码很简单，如下所示：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'>  <span class="k">begin</span>
</span><span class='line'>    <span class="n">res</span> <span class="o">=</span> <span class="no">SneakersPacker</span><span class="o">.</span><span class="n">remote_call</span> <span class="s2">&quot;record.get_simple_profile&quot;</span><span class="p">,</span> <span class="n">params_data</span>
</span><span class='line'>  <span class="k">rescue</span>
</span><span class='line'>    <span class="n">res</span> <span class="o">=</span> <span class="no">HTTPProxy</span><span class="o">::</span><span class="no">Record</span><span class="o">.</span><span class="n">get</span> <span class="s2">&quot;api/v1/users/simple_profile&quot;</span><span class="p">,</span> <span class="n">params_data</span>
</span><span class='line'>  <span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>但是实际运行结果很让人诧异，remote_call 的确触发了异常，但是代码中的 rescue 并没有捕获到异常，而是直接导致程序 500 错误，大量异常记录在日志和监控系统中，让人百思不得其解。在那之前我以为孤立的 <code>rescue</code>会捕获全部异常的，仔细研究网络上的一些文档后，发现并不是这样，rescue 其实只捕获 StandardError 类型的异常。再去查阅 SneakersPacker 的代码，发现原来报了很多的异常 RemoteCallTimeoutError 是这样定义的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'>  <span class="k">class</span> <span class="nc">RemoteCallTimeoutError</span> <span class="o">&lt;</span> <span class="no">Exception</span><span class="p">;</span> <span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>RemoteCallTimeoutError 选择父类 Exception 是错误的，应该选择 StandardError，改成下面之后 RemoteCallTimeoutError 象期望的一样被捕获了。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'>  <span class="k">class</span> <span class="nc">RemoteCallTimeoutError</span> <span class="o">&lt;</span> <span class="no">StandardError</span><span class="p">;</span> <span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>为了说明 rescue 这个关键字的行为，我们看下面几个例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># 代码1</span>
</span><span class='line'><span class="k">begin</span>
</span><span class='line'>  <span class="n">success_job</span>
</span><span class='line'><span class="k">rescue</span>
</span><span class='line'>  <span class="n">fail_job</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># 代码2</span>
</span><span class='line'><span class="k">begin</span>
</span><span class='line'>  <span class="n">success_job</span>
</span><span class='line'><span class="k">rescue</span> <span class="o">=&gt;</span> <span class="n">e</span>
</span><span class='line'>  <span class="n">fail_job</span>
</span><span class='line'>  <span class="nb">puts</span> <span class="err">“</span><span class="n">e</span> <span class="n">is</span> <span class="c1">#{e.inspect}&quot;</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># 代码3</span>
</span><span class='line'><span class="k">begin</span>
</span><span class='line'>  <span class="n">success_job</span>
</span><span class='line'><span class="k">rescue</span> <span class="no">StandardError</span> <span class="o">=&gt;</span> <span class="n">e</span>
</span><span class='line'>  <span class="n">fail_job</span>
</span><span class='line'>  <span class="nb">puts</span> <span class="err">“</span><span class="n">e</span> <span class="n">is</span> <span class="c1">#{e.inspect}&quot;</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># 代码4</span>
</span><span class='line'><span class="k">begin</span>
</span><span class='line'>  <span class="n">success_job</span>
</span><span class='line'><span class="k">rescue</span> <span class="no">Exception</span> <span class="o">=&gt;</span> <span class="n">e</span>
</span><span class='line'>  <span class="n">fail_job</span>
</span><span class='line'>  <span class="nb">puts</span> <span class="err">“</span><span class="n">e</span> <span class="n">is</span> <span class="c1">#{e.inspect}&quot;</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>代码1，代码2和代码3的 rescue 都只捕获 StandardError 类别的异常，而代码4明显不同，代码4会捕获所有 的异常。</p>

<p>一些直接继承自 Exception 而不是 StandardError 的异常包括：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">SystemStackError</span>
</span><span class='line'><span class="no">NoMemoryError</span>
</span><span class='line'><span class="no">SecurityError</span>
</span><span class='line'><span class="no">ScriptError</span>
</span><span class='line'>  <span class="no">NotImplementedError</span>
</span><span class='line'>  <span class="no">LoadError</span>
</span><span class='line'>    <span class="no">Gem</span><span class="o">::</span><span class="no">LoadError</span>
</span><span class='line'>  <span class="no">SyntaxError</span>
</span><span class='line'><span class="no">SignalException</span>
</span><span class='line'>  <span class="no">Interrupt</span>
</span><span class='line'><span class="no">SystemExit</span>
</span><span class='line'>  <span class="no">Gem</span><span class="o">::</span><span class="no">SystemExitException</span>
</span></code></pre></td></tr></table></div></figure>


<p>都是系统层级严重错误，不应该由应用捕获。</p>

<p>综上所述，总结一些 ruby 中捕获异常的原则（正确姿势）
- 最好的 rescue 姿势，捕获明确指定的异常，rescue OneError => e
- 次好的 rescue 姿势，捕获 StandardError，通过 rescue 或 rescue => e
- <strong>千万千万不要</strong> rescue Exception => e，除非真的知道自己在干嘛
- 自己定义的异常应该继承自 StandardError ，而不是 Exception</p>

<p>end.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/05/27/cache-trap/">缓存可能让你的应用更慢 - 缓存使用的 N+1 问题</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-05-27T17:43:00+08:00" pubdate data-updated="true">2015-05-27</time>
        
         | <a href="/blog/2015/05/27/cache-trap/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>缓存是提升系统性能非常有效的手段，常常起到立竿见影的效果，但是有时不恰当的使用不但起不到优化效果，反而可能让系统更慢。下面总结缓存使用过程中常见的一些陷阱。</p>

<p>大家应该比较熟悉数据库查询时的 N+1 问题，在缓存中同样存在 N+1 问题。当应用中出现需要多次读取缓存的时候，虽然单次读取缓存速度很快，但是多次读取缓存累计时间相当可观，很可能会成为一个性能瓶颈。</p>

<p>直接给一个演示例子，生成 10000 个缓存对象 user:<i>:counter 存储整数，然后分别单次，批量读取缓存，统计每种方式消耗时间。</p>

<p>代码如下所示：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">n</span> <span class="o">=</span> <span class="mi">10000</span>
</span><span class='line'><span class="n">n</span><span class="o">.</span><span class="n">times</span> <span class="p">{</span><span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="no">Rails</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">write</span> <span class="s2">&quot;user:</span><span class="si">#{</span><span class="n">i</span><span class="si">}</span><span class="s2">:counter&quot;</span><span class="p">,</span> <span class="n">i</span> <span class="o">*</span> <span class="n">i</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">read_by_batch</span><span class="p">(</span><span class="n">total</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">)</span>
</span><span class='line'>  <span class="n">array</span> <span class="o">=</span> <span class="o">[]</span>
</span><span class='line'>  <span class="n">total</span><span class="o">.</span><span class="n">times</span> <span class="k">do</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">%</span> <span class="n">batch_size</span> <span class="o">==</span> <span class="mi">0</span>
</span><span class='line'>      <span class="no">Rails</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">read_multi</span> <span class="o">*</span><span class="n">array</span>
</span><span class='line'>      <span class="n">array</span> <span class="o">=</span> <span class="o">[]</span>
</span><span class='line'>    <span class="k">else</span>
</span><span class='line'>      <span class="n">array</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;user:</span><span class="si">#{</span><span class="n">i</span><span class="si">}</span><span class="s2">:counter&quot;</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="no">Benchmark</span><span class="o">.</span><span class="n">bm</span> <span class="k">do</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span>
</span><span class='line'>  <span class="n">x</span><span class="o">.</span><span class="n">report</span> <span class="s2">&quot;  1&quot;</span> <span class="k">do</span>
</span><span class='line'>    <span class="n">n</span><span class="o">.</span><span class="n">times</span> <span class="k">do</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span>
</span><span class='line'>      <span class="no">Rails</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">read</span> <span class="s2">&quot;user:</span><span class="si">#{</span><span class="n">i</span><span class="si">}</span><span class="s2">:counter&quot;</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">x</span><span class="o">.</span><span class="n">report</span> <span class="s2">&quot; 10&quot;</span> <span class="k">do</span>
</span><span class='line'>    <span class="n">read_by_batch</span> <span class="n">n</span><span class="p">,</span> <span class="mi">10</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">x</span><span class="o">.</span><span class="n">report</span> <span class="s2">&quot; 30&quot;</span> <span class="k">do</span>
</span><span class='line'>    <span class="n">read_by_batch</span> <span class="n">n</span><span class="p">,</span> <span class="mi">30</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">x</span><span class="o">.</span><span class="n">report</span> <span class="s2">&quot; 50&quot;</span> <span class="k">do</span>
</span><span class='line'>    <span class="n">read_by_batch</span> <span class="n">n</span><span class="p">,</span> <span class="mi">50</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">x</span><span class="o">.</span><span class="n">report</span> <span class="s2">&quot;100&quot;</span> <span class="k">do</span>
</span><span class='line'>    <span class="n">read_by_batch</span> <span class="n">n</span><span class="p">,</span> <span class="mi">100</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>执行结果如下所示：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>   user     system      total        real
</span><span class='line'>  1  0.910000   0.210000   1.120000 <span class="o">(</span>  1.316800<span class="o">)</span>
</span><span class='line'> 10  0.010000   0.000000   0.010000 <span class="o">(</span>  0.013985<span class="o">)</span>
</span><span class='line'> 30  0.010000   0.000000   0.010000 <span class="o">(</span>  0.009109<span class="o">)</span>
</span><span class='line'> 50  0.010000   0.000000   0.010000 <span class="o">(</span>  0.009200<span class="o">)</span>
</span><span class='line'>100  0.040000   0.010000   0.050000 <span class="o">(</span>  0.044768<span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>从结果中可以看到，分批读取（每次 30~50时）速度很快，要比每次 1 个对象快 100 多倍，每次读取 10 个对象也要快 100 倍，批次并不是越大越好，每次读取 100 个速度比 10 个更慢。</p>

<p>在薄荷生产系统性能优化中，我们遇到过好几次类似的问题。例如有一个 api 需要返回多个存放缓存的用户资料，单个用户资料缓存读取时间接近 1 ms，50 个用户资料消耗接近 45 ms 时间，它导致这个 api 响应时间很长，把 50 次用户资料缓存读取放到一次批量读取后，缓存读取时间减少为 3 ms 左右，应用性能立即大幅提升。</p>

<p>为什么批量读取时间消耗大幅减少呢？因为每一次缓存读取过程有很多固定开销，包括加锁，系统（网络）调用等等，当使用批量读取时，这些固定开销统统节省了，而缓存服务器单次 key 查找和数据返回消耗时间差别不大，所以整体时间大幅减少。</p>

<p>当然，批量读取增加了应用的复杂度，如果应用性能没有问题，或者缓存读取次数很少，并没有必要改造成批量读取形式。</p>

<p>最后一点是，通常我们以 fetch 方法使用缓存对象，这时批量读取方法如下所示：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'>  <span class="n">keys</span> <span class="o">=</span> <span class="n">user_ids</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">user_id</span><span class="o">|</span> <span class="s2">&quot;user:</span><span class="si">#{</span><span class="n">user_id</span><span class="si">}</span><span class="s2">&quot;</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">user_hash</span> <span class="o">=</span> <span class="no">Rails</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">fetch_multi</span><span class="p">(</span><span class="o">*</span><span class="n">keys</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">key</span><span class="o">|</span>
</span><span class='line'>    <span class="no">User</span><span class="o">.</span><span class="n">find_by_id</span> <span class="n">key</span><span class="o">.</span><span class="n">gsub</span><span class="p">(</span><span class="s1">&#39;user:&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
</span><span class='line'>  <span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>总结：缓存虽然很快，但它毕竟也是一次 IO 操作，同样需要消耗一定时间，如果某一次特别大量读写缓存，很可能会以前性能问题，通过批量读取方式是解决该问题的有效手段。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/03/22/four-equality-operations-in-ruby/">ruby 中的 4 种相等性判断方法</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-03-22T23:14:00+08:00" pubdate data-updated="true">2015-03-22</time>
        
         | <a href="/blog/2015/03/22/four-equality-operations-in-ruby/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>很早就知道 ruby 有 4 种相等性判断方法，分别是：“==”，“===”，“equal?” 和 “eql?”，平常程序中都有使用，但是感觉对其缺乏深入理解，今天读 rails 部分源码的时候拿捏不定其中一个判断的意思，于是趁机深入研究了一番，总算觉得比较清楚了，今天做一下笔记，以作备忘。</p>

<h2>“==” 最常见的相等性判断</h2>

<p>“==” 使用最频繁，它通常用于对象的值相等性（语义相等）判断，在 Object 的方法定义中，“==” 比较两个对象的 object_id 是否一致，通常子类都会重写覆盖这个方法，通过比较内部值来判断对象是否相等。</p>

<p>比如 ActiveRecord::Base 对 &#8220;==&#8221; 的定义</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'>  <span class="k">def</span> <span class="nf">==</span><span class="p">(</span><span class="n">comparison_object</span><span class="p">)</span>
</span><span class='line'>    <span class="k">super</span> <span class="o">||</span>
</span><span class='line'>      <span class="n">comparison_object</span><span class="o">.</span><span class="n">instance_of?</span><span class="p">(</span><span class="nb">self</span><span class="o">.</span><span class="n">class</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
</span><span class='line'>      <span class="nb">id</span><span class="o">.</span><span class="n">present?</span> <span class="o">&amp;&amp;</span>
</span><span class='line'>      <span class="n">comparison_object</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="nb">id</span>
</span><span class='line'>  <span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>通过 model 的 id 属性比较两个 ActiveRecord::Base 实例是否相等。</p>

<h2>“===” 用于 case 语句的相容判断</h2>

<p>“===” 主要用于 case 语句中对象的相容比较，看代码比较容易理解。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">what_is</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
</span><span class='line'>  <span class="k">case</span> <span class="n">obj</span>
</span><span class='line'>    <span class="k">when</span> <span class="sr">/abc/</span>
</span><span class='line'>      <span class="nb">puts</span> <span class="s2">&quot;include abc&quot;</span>
</span><span class='line'>    <span class="k">when</span> <span class="mi">3</span><span class="o">.</span><span class="n">.</span><span class="mi">5</span>
</span><span class='line'>      <span class="nb">puts</span> <span class="s2">&quot;in 3..5&quot;</span>
</span><span class='line'>    <span class="k">when</span> <span class="no">Symbol</span>
</span><span class='line'>      <span class="nb">puts</span> <span class="s2">&quot;It is a symbol&quot;</span>
</span><span class='line'>    <span class="k">else</span>
</span><span class='line'>      <span class="nb">puts</span> <span class="s2">&quot;unkonwn&quot;</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="n">what_is</span><span class="p">(</span><span class="s2">&quot;abcde&quot;</span><span class="p">)</span> <span class="c1"># =&gt;  &quot;include abc&quot;</span>
</span><span class='line'><span class="n">what_is</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>       <span class="c1"># =&gt;  &quot;in 3..5&quot;</span>
</span><span class='line'><span class="n">what_is</span><span class="p">(</span><span class="ss">:a</span><span class="p">)</span>      <span class="c1"># =&gt;  &quot;It is a symbol&quot;</span>
</span><span class='line'><span class="n">what_is</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>     <span class="c1"># =&gt;  &quot;unknown&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>case 背后是拿每一个 when 后面的对象与 obj 进行 === 方法计算比较，比如上面的代码就是
分别求 <code>/abc/.===(obj)</code>，<code>(3..5).===(obj)</code>，<code>Symbol.===(obj)</code>。</p>

<p>关键得看 <code>===</code> 方法里如何定义，<code>Class</code> 类中，<code>===</code> 定义为 obj.is_a?(klass)，所以 case 可以现实 obj 的类型判断。</p>

<p>特别要注意的是和其他相等判断不同 “===” 通常没法交换，也就是很可能
  <code>a.===(b) != b.===(a)</code> ，比如  <code>/abc/ === "abcd"</code> 为 true，但 <code>"abcd" === /abc/</code> 为 false。</p>

<h2>“equal?” 相同对象判断</h2>

<p>“equal?” 其实是最简单的，但是也是最容易让人搞混的判断。说它简单是因为这个方法的语义是比较两个对象是否相同（是否有相同的 object_id），Object 的方法适用所有对象，不应该对其重写覆盖。说它容易让人搞混，是因为 ruby 和 java 中 “==” 和 &#8220;equal?&#8221; 方法的语义正好是相反的，ruby 中 “equal?” 表示对象引用相同，而 java 表示对象值相同。</p>

<h2>“eql?” 对象 hash 值判断</h2>

<p><code>eql?</code> 用于对象 hash 值判断，如果两个对象的 hash 值相等，就返回 true，否则返回 false。Object 的定义里，“eql?” 和 “==” 是等价的。通常可以把 “eql?” 看作比 “==” 更严格的相等，比如:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="mi">1</span> <span class="o">==</span> <span class="mi">1</span><span class="o">.</span><span class="mi">0</span>     <span class="c1">#=&gt; true</span>
</span><span class='line'><span class="mi">1</span><span class="o">.</span><span class="n">eql?</span> <span class="mi">1</span><span class="o">.</span><span class="mi">0</span>   <span class="c1">#=&gt; false</span>
</span></code></pre></td></tr></table></div></figure>



</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/02/01/refactor-broadcast-feature/">重构系统广播功能</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-02-01T21:16:00+08:00" pubdate data-updated="true">2015-02-01</time>
        
         | <a href="/blog/2015/02/01/refactor-broadcast-feature/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>以前薄荷伙伴子系统的广播功能使用 redis 存储数据，随着时间推移数据积累，消耗内存十分严重，属于典型的 redis 误用。现在进行大幅重构，更改为 cache + storage 的存储方式，取消了 redis 存储。重构后，消耗资源大幅下降，性能上还有所改进。</p>

<p>先说说广播功能特性。广播功能主要用于薄荷向全体用法传递的消息（包括各种广告，告示和提醒等），当系统管理员在后台发出一条广播后，用户 app 上的消息图标显示小红点，当用户点击图标进入广播列表查看消息内容后，小红点消除。</p>

<p>重构前，广播功能采用了 redis 存储方案，为每一位用户建立一个已读广播集合 set，该 set 中存放用户已读的广播 id。最常见的操作是获取某位用户未读广播和数量，其方法是：使用全体 广播 id 集合与已读广播 id 集合比较，差异部分就是未读广播，对其计数得到未读广播数量。</p>

<p>这种方法的问题有两个：一是 redis 消耗内存巨大，随着用户数增加和发送广播数量增加，内存一直累积；二是当广播数量增加到比较大的数量后，获取未读广播很慢。</p>

<p>对其重构如下：去除了 redis 存储，在数据库中存储每一个用户最新访问广播的时间 last_read_time，建立一个全体的广播列表缓存，广播列表只存放广播 id 和 created_time，列表根据 created_time 从新到旧排序。获取某个用户未读广播和其数量方法：把广播列表缓存的生成时间 created_time 和用户的 last_read_time 比较，比 last_read_time 大的属于未读广播，比 last_read_time 小的属于已读广播。</p>

<p>这次重构，去除 redis 存储，大幅减少内存使用，算法调整让常见操作速度更快，效果很棒。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/01/11/mattr-accessor-in-ruby-on-rails-activesupport/">Rails 中 mattr_accessor 一处文档错误</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-01-11T21:49:00+08:00" pubdate data-updated="true">2015-01-11</time>
        
         | <a href="/blog/2015/01/11/mattr-accessor-in-ruby-on-rails-activesupport/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>发现错误</h2>

<p>最近写一个 gem 的时候偶然接触到 Rails ActiveSupport 扩展 module 的 mattr_accessor 系列方法，包括 mattr_accessor、mattr_reader 和 mattr_writer。
记得以前探索 Rails 源代码的时候经常遇到 mattr_accessor 方法，当时并没有细究，这次碰巧要自己用到，所以仔细研究了其文档和实现源码，居然发现文档描述有明显的错误。</p>

<p>Rails 的官方文档中提到，mattr_accessor 用于为类属性定义类和实例对象两者的访问器，然后还提供一段示例代码演示其用法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">mattr_accessor</span><span class="p">(</span><span class="o">*</span><span class="n">syms</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">blk</span><span class="p">)</span> <span class="kp">public</span>
</span><span class='line'><span class="no">Defines</span> <span class="n">both</span> <span class="k">class</span> <span class="ow">and</span> <span class="n">instance</span> <span class="n">accessors</span> <span class="k">for</span> <span class="k">class</span> <span class="n">attributes</span><span class="o">.</span>
</span></code></pre></td></tr></table></div></figure>


<p>演示代码如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">HairColors</span>
</span><span class='line'>  <span class="n">mattr_accessor</span> <span class="ss">:hair_colors</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Person</span>
</span><span class='line'>  <span class="kp">include</span> <span class="no">HairColors</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="no">Person</span><span class="o">.</span><span class="n">hair_colors</span> <span class="o">=</span> <span class="o">[</span><span class="ss">:brown</span><span class="p">,</span> <span class="ss">:black</span><span class="p">,</span> <span class="ss">:blonde</span><span class="p">,</span> <span class="ss">:red</span><span class="o">]</span>
</span><span class='line'><span class="no">Person</span><span class="o">.</span><span class="n">hair_colors</span>     <span class="c1"># =&gt; [:brown, :black, :blonde, :red]</span>
</span><span class='line'><span class="no">Person</span><span class="o">.</span><span class="n">new</span><span class="o">.</span><span class="n">hair_colors</span> <span class="c1"># =&gt; [:brown, :black, :blonde, :red]</span>
</span></code></pre></td></tr></table></div></figure>


<p>当我运行该代码的时候，发现无法运行，报错在 <code>Person.hair_colors</code> 处，信息如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="o">[</span><span class="mi">5</span><span class="o">]</span> <span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="no">Person</span><span class="o">.</span><span class="n">hair_colors</span> <span class="o">=</span> <span class="o">[</span><span class="ss">:brown</span><span class="p">,</span> <span class="ss">:black</span><span class="p">,</span> <span class="ss">:blonde</span><span class="p">,</span> <span class="ss">:red</span><span class="o">]</span>
</span><span class='line'><span class="no">NoMethodError</span><span class="p">:</span> <span class="n">undefined</span> <span class="nb">method</span> <span class="sb">`hair_colors=&#39; for Person:Class</span>
</span><span class='line'><span class="sb">from (pry):7:in `</span><span class="n">__pry__</span><span class="err">&#39;</span>
</span></code></pre></td></tr></table></div></figure>


<p>刚开始还有点不相信，分别在 Rails 4.1.8，4.2.0 和 3.2.x，Ruby 1.9.3，2.0.0 和 2.1.5 下运行， 都出现这个错误，这下确信文档描述应该是有问题的。我想把问题彻底搞清楚，于是仔细查看 Rails ActiveSupport 中相关的源代码，发现的确是文档描述的行为和程序实际行为不符。</p>

<h2>探寻原因</h2>

<p>mattr_accessor 系列方法的代码在 <code>rails/activesupport/lib/active_support/core_ext/module/attribute_accessors.rb</code> 文件中，相关的代码并不复杂，部分代码如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'>  <span class="c1"># 此处忽略注释</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">mattr_writer</span><span class="p">(</span><span class="o">*</span><span class="n">syms</span><span class="p">)</span>
</span><span class='line'>    <span class="n">options</span> <span class="o">=</span> <span class="n">syms</span><span class="o">.</span><span class="n">extract_options!</span>
</span><span class='line'>    <span class="n">syms</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">sym</span><span class="o">|</span>
</span><span class='line'>      <span class="k">raise</span> <span class="no">NameError</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s2">&quot;invalid attribute name: </span><span class="si">#{</span><span class="n">sym</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="k">unless</span> <span class="n">sym</span> <span class="o">=~</span> <span class="sr">/^[_A-Za-z]\w*$/</span>
</span><span class='line'>      <span class="nb">class_eval</span><span class="p">(</span><span class="o">&lt;&lt;-</span><span class="no">EOS</span><span class="p">,</span> <span class="bp">__FILE__</span><span class="p">,</span> <span class="bp">__LINE__</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</span><span class='line'><span class="sh">        @@#{sym} = nil unless defined? @@#{sym}</span>
</span><span class='line'>
</span><span class='line'><span class="sh">        def self.#{sym}=(obj)</span>
</span><span class='line'><span class="sh">          @@#{sym} = obj</span>
</span><span class='line'><span class="sh">        end</span>
</span><span class='line'><span class="no">      EOS</span>
</span><span class='line'>
</span><span class='line'>      <span class="k">unless</span> <span class="n">options</span><span class="o">[</span><span class="ss">:instance_writer</span><span class="o">]</span> <span class="o">==</span> <span class="kp">false</span> <span class="o">||</span> <span class="n">options</span><span class="o">[</span><span class="ss">:instance_accessor</span><span class="o">]</span> <span class="o">==</span> <span class="kp">false</span>
</span><span class='line'>        <span class="nb">class_eval</span><span class="p">(</span><span class="o">&lt;&lt;-</span><span class="no">EOS</span><span class="p">,</span> <span class="bp">__FILE__</span><span class="p">,</span> <span class="bp">__LINE__</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</span><span class='line'><span class="sh">          def #{sym}=(obj)</span>
</span><span class='line'><span class="sh">            @@#{sym} = obj</span>
</span><span class='line'><span class="sh">          end</span>
</span><span class='line'><span class="no">        EOS</span>
</span><span class='line'>      <span class="k">end</span>
</span><span class='line'>      <span class="nb">send</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">#{</span><span class="n">sym</span><span class="si">}</span><span class="s2">=&quot;</span><span class="p">,</span> <span class="k">yield</span><span class="p">)</span> <span class="k">if</span> <span class="nb">block_given?</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1"># 此处忽略注释</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">mattr_accessor</span><span class="p">(</span><span class="o">*</span><span class="n">syms</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">blk</span><span class="p">)</span>
</span><span class='line'>    <span class="n">mattr_reader</span><span class="p">(</span><span class="o">*</span><span class="n">syms</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">blk</span><span class="p">)</span>
</span><span class='line'>    <span class="n">mattr_writer</span><span class="p">(</span><span class="o">*</span><span class="n">syms</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">blk</span><span class="p">)</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p>从中可以看到，mattr_accessor 分别 call mattr_reader 和 mattr_writer，mattr_writer 的主要逻辑是定义类变量（class variable，命名为 <code>@@#{sym}</code>），然后定义类方法 （见 <code>def self.#{sym}=(obj)</code>）和普通实例方法（见 <code>def #{sym}=(obj)</code>）。当 <code>Person include HairColors</code> 的时候，普通实例方法是 mix 进 Person 的，但类方法并不会被 mix 进 Person。可以用下面更简明的例子演示 include module 并不能 mix 类方法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'>  <span class="k">module</span> <span class="nn">Foo</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">method1</span>
</span><span class='line'>      <span class="nb">puts</span> <span class="s2">&quot;method1 in Foo&quot;</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">method2</span>
</span><span class='line'>      <span class="nb">puts</span> <span class="s2">&quot;method2 in Foo as class method&quot;</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">class</span> <span class="nc">Bar</span>
</span><span class='line'>    <span class="kp">include</span> <span class="no">Foo</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="no">Bar</span><span class="o">.</span><span class="n">new</span><span class="o">.</span><span class="n">method1</span>  <span class="c1"># =&gt; &quot;method1 in Foo&quot;</span>
</span><span class='line'>
</span><span class='line'>  <span class="no">Foo</span><span class="o">.</span><span class="n">method2</span> <span class="c1"># =&gt; &quot;method2 in Foo as class method&quot;</span>
</span><span class='line'>
</span><span class='line'>  <span class="no">Bar</span><span class="o">.</span><span class="n">method2</span> <span class="c1"># =&gt; NoMethodError: undefined method `method2&#39; for #&lt;Bar:0x007fdb0a121488&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>原来 mattr_accessor 为 HairColors 生成的 <code>def self.hair_colors</code> 类方法不能 mix 进 Person，从而导致 Person.hair_colors 出错，但是 Person.new.hair_colors 能够正常运行的。</p>

<h2>解决方法</h2>

<p>如果希望 Person 通过类方法和实例方法都能使用 hair_colors ，应该怎么做呢？
可以把 mattr_accessor 放在 included 钩子中执行，代码如下所示：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">HairColors</span>
</span><span class='line'>  <span class="kp">extend</span> <span class="no">ActiveSupport</span><span class="o">::</span><span class="no">Concern</span>
</span><span class='line'>  <span class="n">included</span> <span class="k">do</span>
</span><span class='line'>    <span class="n">mattr_accessor</span> <span class="ss">:hair_colors</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Person</span>
</span><span class='line'>  <span class="kp">include</span> <span class="no">HairColors</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="no">Person</span><span class="o">.</span><span class="n">hair_colors</span> <span class="o">=</span> <span class="o">[</span><span class="ss">:brown</span><span class="p">,</span> <span class="ss">:black</span><span class="p">,</span> <span class="ss">:blonde</span><span class="p">,</span> <span class="ss">:red</span><span class="o">]</span>
</span><span class='line'><span class="no">Person</span><span class="o">.</span><span class="n">hair_colors</span>     <span class="c1"># =&gt; [:brown, :black, :blonde, :red]</span>
</span><span class='line'><span class="no">Person</span><span class="o">.</span><span class="n">new</span><span class="o">.</span><span class="n">hair_colors</span> <span class="c1"># =&gt; [:brown, :black, :blonde, :red]</span>
</span><span class='line'><span class="no">HairColors</span><span class="o">.</span><span class="n">hair_colors</span> <span class="c1"># =&gt; undefined method `hair_colors&#39; for HairColors:Module</span>
</span></code></pre></td></tr></table></div></figure>


<p>它的一个问题是 <code>HairColors.hair_colors</code> 不可用了，但我发现 Rails 中大多是使用这种手法处理的，这种情况下估计不怎么要直接用到 <code>HairColors.hair_colors</code> 吧。</p>

<h2>总结</h2>

<p>Rails 官方文档中关于 mattr_accessor 的描述的确有问题，示例代码不能正确运行，而且还会误导使用者，通过仔细探索 Rails 的源代码，找到了问题的源头。我已经修正文档的错误，提交了 <code>pull request</code>，希望能够被接受。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/12/28/cardinality-counting-using-redis/">使用 Redis 进行唯一计数的 3 种方法</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-12-28T23:06:00+08:00" pubdate data-updated="true">2014-12-28</time>
        
         | <a href="/blog/2014/12/28/cardinality-counting-using-redis/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>唯一计数是网站系统中十分常见的一个功能特性，例如网站需要统计每天访问的人数 unique visitor （也就是 UV）。计数问题很常见，但解决起来可能十分复杂：一是需要计数的量可能很大，比如大型的站点每天有数百万的人访问，数据量相当大；二是通常还希望扩展计数的维度，比如除了需要每天的 UV，还想知道每周或每月的 UV，这样导致计算十分复杂。</p>

<p>在关系数据库存储的系统里，实现唯一计数的方法就是 <code>select count(distinct &lt;item_id&gt;)</code>，它十分简单，但是如果数据量很大，这个语句执行是很慢的。用关系数据库另外一个问题是插入数据性能也不高。</p>

<p>Redis 解决这类计数问题得心应手，相比关系数据库速度更快，消耗资源更少，甚至提供了 3 种不同的方法。</p>

<ul>
<li>1.基于 set</li>
</ul>


<p>Redis 的 set 用于保存唯一的数据集合，通过它可以快速判断某一个元素是否存在于集合中，也可以快速计算某一个集合的元素个数，另外和可以合并集合到一个新的集合中。涉及的命令如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>SISMEMBER key member  # 判断 member 是否存在
</span><span class='line'>SADD key member  # 往集合中加入 member
</span><span class='line'>SCARD key   # 获取集合元素个数 </span></code></pre></td></tr></table></div></figure>


<p>基于 set 的方法简单有效，计数精确，适用面广，易于理解，它的缺点是消耗资源比较大（当然比起关系数据库是少很多的），如果元素个数很大（比如上亿的计数），消耗内存很恐怖。</p>

<ul>
<li>2.基于 bit</li>
</ul>


<p>Redis 的 bit 可以用于实现比 set 内存高度压缩的计数，它通过一个 bit 1 或 0 来存储某个元素是否存在信息。例如网站唯一访客计数，可以把 user_id 作为 bit 的偏移量 offset，设置为 1 表示有访问，使用 1 MB的空间就可以存放 800 多万用户的一天访问计数情况。涉及的命令如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>SETBIT key offset value  # 设置位信息
</span><span class='line'>GETBIT key offset        # 获取位信息
</span><span class='line'>BITCOUNT key [start end] # 计数
</span><span class='line'>BITOP operation destkey key [key ...]  # 位图合并 </span></code></pre></td></tr></table></div></figure>


<p>基于 bit 的方法比起 set 空间消耗小得多，但是它要求元素能否简单映射为位偏移，适用面窄了不少，另外它消耗的空间取决于最大偏移量，和计数值无关，如果最大偏移量很大，消耗内存也相当可观。</p>

<ul>
<li>3.基于 HyperLogLog</li>
</ul>


<p>实现超大数据量精确的唯一计数都是比较困难的，但是如果只是近似的话，计算科学里有很多高效的算法，其中 HyperLogLog Counting 就是其中非常著名的算法，它可以仅仅使用 12 k左右的内存，实现上亿的唯一计数，而且误差控制在百分之一左右。涉及的命令如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>PFADD key element [element ...]  # 加入元素
</span><span class='line'>PFCOUNT key [key ...]   # 计数</span></code></pre></td></tr></table></div></figure>


<p>这种计数方法真的很神奇，我也没有彻底弄明白，有兴趣可以深入研究相关文章。</p>

<p>redis 提供的这三种唯一计数方式各有优劣，可以充分满足不同情况下的计数要求。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/12/14/mysql-partition-table-in-rails/">Rails 中 MySQL 分区表使用的一个注意事项</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-12-14T22:46:00+08:00" pubdate data-updated="true">2014-12-14</time>
        
         | <a href="/blog/2014/12/14/mysql-partition-table-in-rails/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>MySQL 的分区表是一种简单有效的处理极大数据表的特性，通过它可以使应用程序几乎很少改动就能达成对极大数据表的高效处理，但由于 Rails ActiveRecord 设计上一些惯例，可能导致一些数据处理不能利用分区表特性，反而变得很慢，在使用分区表过程中一定要多加注意。</p>

<p>下面以一个例子来说明。在 light 系统中，有一张数据表是 diet_items, 主要字段是 id, schedule_id, meal_order food_id, weight, calory 等等，它的每一条记录表示为用户生成每日的减肥计划（减肥食谱 + 运动计划）中的一条饮食项，平均一条的计划有 10 多条数据，数据量非常大，预计每天生成数据会超过 100 万条，所以对其做了分表处理，根据 schedule_id hash 分成 60 张表，也就是数据将动态分到 60 张表中。分表后 diet_items 的建表语句如下所示：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='sql'><span class='line'><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="o">`</span><span class="n">diet_items</span><span class="o">`</span> <span class="p">(</span>
</span><span class='line'>  <span class="o">`</span><span class="n">id</span><span class="o">`</span> <span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="n">AUTO_INCREMENT</span><span class="p">,</span>
</span><span class='line'>  <span class="o">`</span><span class="n">schedule_id</span><span class="o">`</span> <span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
</span><span class='line'>  <span class="o">`</span><span class="n">meals_order</span><span class="o">`</span> <span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
</span><span class='line'>  <span class="o">`</span><span class="n">food_id</span><span class="o">`</span> <span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">DEFAULT</span> <span class="k">NULL</span><span class="p">,</span>
</span><span class='line'>  <span class="p">....</span>
</span><span class='line'>  <span class="k">KEY</span> <span class="n">id</span> <span class="p">(</span><span class="o">`</span><span class="n">id</span><span class="o">`</span><span class="p">),</span>
</span><span class='line'>  <span class="k">UNIQUE</span> <span class="k">KEY</span> <span class="o">`</span><span class="n">index_diet_items_on_schedule_id_and_id</span><span class="o">`</span> <span class="p">(</span><span class="o">`</span><span class="n">schedule_id</span><span class="o">`</span><span class="p">,</span><span class="o">`</span><span class="n">id</span><span class="o">`</span><span class="p">)</span>
</span><span class='line'><span class="p">)</span>
</span><span class='line'><span class="n">PARTITION</span> <span class="k">BY</span> <span class="n">HASH</span> <span class="p">(</span><span class="n">schedule_id</span><span class="p">)</span>
</span><span class='line'><span class="n">PARTITIONS</span> <span class="mi">60</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>分表之后，所有查询 diet_items 的地方都要求带上 schedule_id，比如获取某一个 schedule 的所有 diet_items，通过 schedule. diet_items，获取某一个 id 的 diet_item 也是通过  <code>schedule.diet_items.find(id)</code> 进行。生成 diet_item 也没有问题，因为生成 diet_item 都是通过 <code>schedule.diet_items.build(data)</code> 方式，在生成的时候都是带了 schedule_id 的。</p>

<p>观察 newrelic 日志，发现 diet_item 的 update 和 destroy 相关的请求特别慢，仔细分析后，发现这两种操作非常忙是由于 ActiveRecord 生成的 sql 并没有带 schedule_id 导致。
diet_item update 操作 ActiveRecord 生成的 sql 语句类似于 <code>update diet_items set … where id = &lt;id&gt;</code>。
diet_item destroy 生成的语句类似于 <code>delete diet_items where id = &lt;id&gt;</code>
因为没有带 schedule_id，导致这两种语句都需要 mysql 扫描 60 张分区表才能够完成一个语句执行，非常慢！</p>

<p>知道原因之后就好办了，把原来的 update 和 destroy 调用改为自定义版本的 update 和 destroy 调用就可以了。</p>

<ul>
<li><p><code>diet_item.update(attributes)</code> 改成 <code>DietItem.where(id: diet_item.id, schedule_id: diet_item.schedule_id).update_all(attributes)</code></p></li>
<li><p><code>diet_item.destroy</code> 改成 <code>DietItem.where(id: diet_item.id, schedule_id: diet_item.schedule_id).delete_all</code></p></li>
</ul>


<p>这样生成的 sql 都带上 schedule_id 条件，从而避免了扫描全部的分区表，性能提升立竿见影。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/11/16/how-to-resolve-updating-conflict-in-rails/">如何解决 Rails 中同时修改冲突</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-11-16T22:51:00+08:00" pubdate data-updated="true">2014-11-16</time>
        
         | <a href="/blog/2014/11/16/how-to-resolve-updating-conflict-in-rails/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Rails 应用程序中操作冲突是一个常见问题，Rails 提供了简单有效的解决方法。</p>

<p>举一个实际的例子：我们的系统里有一个商店模块，商店中重要的一块是对产品信息的管理，比如运营人员常常会编辑产品的信息，包括产品标题，营销口号和价格等等。因为修改十分频繁，碰巧同时编辑提交修改的话，就会偶尔遇到修改丢失的问题，运营人员 A 修改产品标题，运营人员 B 修改价格，A 和 B 提交修改都提示修改成功，但是结果上只是 A 的修改结果生效，B 的修改被 A 的修改冲掉了。</p>

<p>仔细研究原因，发现是因为修改功能缺少操作冲突机制，而修改操作同时发生导致了问题。
如下图所示，A 和 B 同时从数据库中查询数据，在 web 页面中修改同样的数据，提交保存时是以 web 页面中提交的数据为准，从而导致 A 的修改把 B 的修改给覆盖了。</p>

<p><img src="/images/house/rails_conflict.png" alt="A和B修改冲突" /></p>

<p>Rails 的 乐观锁<a href="http://api.rubyonrails.org/classes/ActiveRecord/Locking/Optimistic.html">Optimistic Locking</a> 是解决这个问题的有力工具，它的原理是在数据库表中增加一个字段（默认是 lock_version，可配置）记录数据的版本号，每个提交的修改都带上这个版本号，在真正 update 修改数据之前，先判断提交的 lock_version 数据和数据库中的是否一致，如果不一致，则认为发生数据冲突，将抛出 <code>ActiveRecord::StaleObjectError</code> 异常，这样程序就可以捕获这个异常，提醒用户发生了冲突，由用户去协调解决冲突。</p>

<p>相关示例代码如下所示：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># migration: add lock_version to products</span>
</span><span class='line'><span class="n">add_column</span> <span class="ss">:products</span><span class="p">,</span> <span class="ss">:lock_version</span><span class="p">,</span> <span class="ss">:integer</span><span class="p">,</span> <span class="n">defalut</span><span class="p">:</span> <span class="mi">0</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># update product with StaleObjectError checking</span>
</span><span class='line'><span class="k">begin</span>
</span><span class='line'>  <span class="n">product</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">params</span><span class="o">[</span><span class="ss">:product</span><span class="o">]</span><span class="p">)</span>
</span><span class='line'><span class="k">rescue</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">StaleObjectError</span>
</span><span class='line'>  <span class="n">render</span> <span class="s1">&#39;confilct&#39;</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/10/26/a-http-sniffer-tool-pproxy/">http 抓包分析工具 pproxy</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-10-26T23:26:00+08:00" pubdate data-updated="true">2014-10-26</time>
        
         | <a href="/blog/2014/10/26/a-http-sniffer-tool-pproxy/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>引言</h2>

<p>  web 开发和 API 开发中难免要详细分析 http 请求和响应信息。web 开发的话，浏览器提供了便利的工具，比如 chrome 和 IE 都带了 develop tool，而 firefox 更是有十分强大的 firebug，可以让 http 请求的所有秘密一览无遗。目前是 app 大流行的时代，想要观察 app 中得 http 请求的秘密，浏览器的工具和插件都无能为力，有不少本地化的软件可以很好的解决这个问题，Windows 平台下有大名鼎鼎的 Fiddler 和 HttpWatch，Mac 平台下有 Charles。Charles 是一个收费软件，价格不菲要 $50。钱还不是关键问题，作为一名 geek，当然想更向往开源，轻量的解决方案了，无意中发现 pproxy，简单使用了一下，觉得相当棒，可以做绝佳的替代方案。</p>

<h2>比较</h2>

<p>  pproxy 和 Fiddler、Charles 最大的不同是，它是一个开源软件，使用 go 编写，代码托管在 github 上。因为开源，作为一名 geek，就可以通过阅读源代码对其工作机制一探究竟，如果发觉某些方面不能满足需求，可以直接向开发者提需求，也可以自己动手，丰衣足食，造福大众。</p>

<p>  pproxy 的工作机制和本地化软件如 Fiddler、Charles 差别很大。Fiddler 和 Charles 是一个本地化软件，通常是安装在桌面电脑上，通过在桌面电脑建立 proxy，然后截获的 http 请求和响应数据，提供一个本地化的 UI 界面提供服务。而 pproxy 是一个服务端软件，通常安装在 Linux 服务器上（当然也是可以安装在桌面电脑上），在服务器上建立 proxy 截获 http 请求和响应数据，另外提供一个远程的基于 web (html5)的 UI 界面提供服务。</p>

<p>  Fiddler UI 如下所示：</p>

<p>  <img src="/images/house/fiddler.gif" alt="Fiddler UI" /></p>

<p>  pproxy UI 如下所示：</p>

<p>  <img src="/images/house/pproxy.png" alt="pproxy UI" /></p>

<h2>使用</h2>

<p>  pproxy 使用比较简单，具体可以参考其使用说明 <a href="https://github.com/hidu/pproxy">pproxy</a>。
  难得的是他的作者是中国人，所以说明都是中文的。</p>

<h2>总结</h2>

<p>  pproxy 是一个开源的轻巧的 http 抓包分析工具，尤其适合 API http 请求分析，完全可以替换昂贵的收费工具，同时也可以探索其源码学习 GO 语言，学习 http 协议和分析方法。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/08/31/avoid-misusing-redis/">避免误用 Redis</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-08-31T23:29:00+08:00" pubdate data-updated="true">2014-08-31</time>
        
         | <a href="/blog/2014/08/31/avoid-misusing-redis/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Redis 是目前 NoSQL 领域的当红炸子鸡，它象一把瑞士军刀，小巧、锋利、实用，特别适合解决一些使用传统关系数据库难以解决的问题。但是 Redis 不是银弹，有很多适合它解决的问题，但是也有很多并不适合它解决的问题。另外，Redis 作为内存数据库，如果用在不适合的场合，对内存的消耗是很可观的，甚至会让系统难以承受。</p>

<p>我们可以对系统存储使用的数据以两种角度分类，一种是按数据的大小划分，分成大数据和小数据，另一种是按数据的冷热程度划分，分成冷数据和热数据，热数据是指读或写比较频繁的数据，反之则是冷数据。</p>

<p>可以举一些具体的例子来说明数据的大小和冷热属性。比如网站总的注册用户数，这明显是一个小而热的数据，小是因为这个数据只有一个值，热是因为注册用户数随时间变化很频繁。再比如，用户最新访问时间数据，这是一个量比较大，冷热不均的数据，大是数据的粒度是用户级别，每一个用户都有数据，如果有一千万用户，就意味着有一千万的数据，冷热不均是因为活跃用户的最新访问时间变化很频繁，但是可能有很大一部非活跃用户访问时间长时间不会发生变化。</p>

<p>大体而言，Redis 最适合处理的是小而热，而且是写频繁，或者读写都比较频繁的热数据。对于大而热的数据，如果其它方式很难解决问题，也可以考虑使用 Redis 解决，但是一定要非常谨慎，防止数据无限膨胀。原因如下：</p>

<p>首先，对于冷数据，无论大小，都不建议放在 Redis 中。Redis 数据要全部放在内存中，资源宝贵，把冷数据放在其中实在是一种浪费，冷数据放在普通的存储比如关系数据库中就好了。</p>

<p>其次，对于热数据，尤其是写频繁的热数据，如果量比较小，是最适合放到 Redis 中的。比如上面提到的网站总的注册用户数，就是典型的 Redis 用做计数器的例子。再比如论坛最新发表列表，最新报名列表，可以控制数量在几百到一千的规模，也是典型的 redis 做最新列表的使用方式。</p>

<p>另外，对于量比较大的热数据（或者冷热不均数据），使用 Redis 时一定要比较谨慎。这种类型数据很容易引起数据膨胀，导致 Redis 消耗内存巨大，让系统难以承受。薄荷的一个惨痛教训是把用户关注（以及被关注）数据放在 Redis 中，这是一种数据量极大，冷热很不均衡的数据，在几百万的用户级别就占用了近 10 GB左右内存，让 Redis 变得难以应付。应对这种类型的数据，可以用普通存储 + 缓存的方式。</p>

<p>如果用对了地方，比如在小而热的数据情形，Redis 表现很棒，如果用错了地方，Redis 也会带来昂贵的代价，所以使用时务必谨慎。</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/2/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2016/02/21/how-to-rescue-exception-in-ruby/">怎样才是 ruby 中捕获异常的正确姿势？</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/05/27/cache-trap/">缓存可能让你的应用更慢 - 缓存使用的 N+1 问题</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/03/22/four-equality-operations-in-ruby/">ruby 中的 4 种相等性判断方法</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/02/01/refactor-broadcast-feature/">重构系统广播功能</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/01/11/mattr-accessor-in-ruby-on-rails-activesupport/">Rails 中 mattr_accessor 一处文档错误</a>
      </li>
    
  </ul>
</section>






  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2016 - vincent -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'bohe';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>











</body>
</html>
